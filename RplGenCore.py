#!/usr/bin/env python
# coding: utf-8
from Utils import EDITION

import argparse
import sys
import os

# 参数处理
ap = argparse.ArgumentParser(description="Generating your TRPG replay video from logfile.")
ap.add_argument("-l", "--LogFile", help='The standerd input of this programme, which is mainly composed of TRPG log.',type=str)
ap.add_argument("-d", "--MediaObjDefine", help='Definition of the media elements, using real python code.',type=str)
ap.add_argument("-t", "--CharacterTable", help='The correspondence between character and media elements, using tab separated text file or Excel table.',type=str)
ap.add_argument("-o", "--OutputPath", help='Choose the destination directory to save the project timeline and breakpoint file.',type=str,default=None)
ap.add_argument("-i", "--TimeLine", help='Timeline (and break_point with same name), which was generated by replay_generator.',type=str)
# 选项
ap.add_argument("-F", "--FramePerSecond", help='Set the FPS of display, default is 30 fps, larger than this may cause lag.',type=int,default=30)
ap.add_argument("-W", "--Width", help='Set the resolution of display, default is 1920, larger than this may cause lag.',type=int,default=1920)
ap.add_argument("-H", "--Height", help='Set the resolution of display, default is 1080, larger than this may cause lag.',type=int,default=1080)
ap.add_argument("-Z", "--Zorder", help='Set the display order of layers, not recommended to change the values unless necessary!',type=str,
                default='BG2,BG1,Am3,Am2,Am1,AmS,Bb,BbS')
# 用于语音合成的key
ap.add_argument("-K", "--AccessKey", help='Your AccessKey, to use with --SynthsisAnyway',type=str,default="Your_AccessKey")
ap.add_argument("-S", "--AccessKeySecret", help='Your AccessKeySecret, to use with --SynthsisAnyway',type=str,default="Your_AccessKey_Secret")
ap.add_argument("-A", "--Appkey", help='Your Appkey, to use with --SynthsisAnyway',type=str,default="Your_Appkey")
ap.add_argument("-U", "--Azurekey", help='Your Azure TTS key.',type=str,default="Your_Azurekey")
ap.add_argument("-R", "--ServRegion", help='Service region of Azure.', type=str, default="eastasia")
# 用于导出视频的质量值
ap.add_argument("-Q", "--Quality", help='Choose the quality (ffmpeg crf) of output video, to use with --ExportVideo.',type=int,default=24)
# Flags
ap.add_argument('--ExportXML',help='Export a xml file to load in Premiere Pro, some .png file will be created at same time.',action='store_true')
ap.add_argument('--ExportVideo',help='Export MP4 video file, this will disables interface display',action='store_true')
ap.add_argument('--SynthesisAnyway',help='Execute speech_synthezier first, and process all unprocessed asterisk time label.',action='store_true')
ap.add_argument('--FixScreenZoom',help='Windows system only, use this flag to fix incorrect windows zoom.',action='store_true')
# 语音合成预览flag
ap.add_argument('--PreviewOnly',help='Ignore the input files, and open a speech preview gui windows.',action='store_true')
ap.add_argument('--Init',help='The initial speech service in preview.',type=str,default='Aliyun')
# 语言
ap.add_argument("--Language",help='Choose the language of running log',default='en',type=str)
ap.add_argument('--Modules',help='Choose subprogram. Choice: replay_generator, speech_synthesizer, export_xml, export_video.',type=str,default='replay_generator')

args = ap.parse_args()

if args.Modules == 'replay_generator':
    # 异常和运行日志
    from core.Exceptions import RplGenError, Print
    from core.Exceptions import ParserError, RenderError, ArgumentError, MediaError, SyntaxsError, SynthesisError, DecodeError
    from core.Exceptions import MainPrint, WarningPrint, CMDPrint
    Width,Height = args.Width,args.Height #显示的分辨率
    frame_rate = args.FramePerSecond #帧率 单位fps
    zorder = args.Zorder.split(',') #渲染图层顺序

    # 初始化日志打印
    if args.Language == 'zh':
        # 中文
        Print.lang = 1 
        RplGenError.lang = 1
    else:
        # 英文
        Print.lang == 0
        RplGenError.lang = 0
    # 退出程序
    def system_terminated(exit_type='Error'):
        print(MainPrint(exit_type))
        if exit_type == 'Error':
            # import traceback
            # traceback.print_exc()
            sys.exit(1) # 错误退出的代码
        else:
            sys.exit(0) # 正常退出的代码

    try:
        for path in [args.LogFile,args.MediaObjDefine,args.CharacterTable]:
            if path is None:
                raise ArgumentError('MissInput')
            if os.path.isfile(path) == False:
                raise ArgumentError('FileNotFound',path)

        if args.OutputPath is None:
            if (args.SynthesisAnyway == True) | (args.ExportXML == True) | (args.ExportVideo == True):
                raise ArgumentError('NeedOutput')
        elif os.path.isdir(args.OutputPath) == False:
            raise ArgumentError('DirNotFound',args.OutputPath)
        else:
            args.OutputPath = args.OutputPath.replace('\\','/')

        # FPS
        if frame_rate <= 0:
            raise ArgumentError('FrameRate',str(frame_rate))
        elif frame_rate>30:
            print(WarningPrint('HighFPS',str(frame_rate)))

        if (Width<=0) | (Height<=0):
            raise ArgumentError('Resolution',str((Width,Height)))
        if Width*Height > 3e6:
            print(WarningPrint('HighRes'))
    except Exception as E:
        print(E)
        system_terminated('Error')

    # 包导入

    import pandas as pd
    import numpy as np
    import pygame
    import pygame.freetype
    import re
    import time #开发模式，显示渲染帧率
    import pickle

    # 自由点
    from core.FreePos import Pos,FreePos,PosGrid

    # 类定义 alpha 1.11.0
    from core.Medias import Text
    from core.Medias import StrokeText
    from core.Medias import Bubble
    from core.Medias import Balloon
    from core.Medias import DynamicBubble
    from core.Medias import ChatWindow
    from core.Medias import Background
    from core.Medias import Animation
    from core.Medias import GroupedAnimation
    from core.Medias import BuiltInAnimation
    from core.Medias import Audio
    from core.Medias import BGM
    # 窗体参数
    from core.Medias import screen_config
    screen_config['screen_size'] = (Width,Height)
    screen_config['frame_rate'] = frame_rate
    # 色图
    from core.Medias import cmap

    # 正则表达式
    from core.Regexs import *

    # 曲线函数
    from core.Formulas import linear,quadratic,quadraticR,sigmoid,right,left,sincurve,normalized
    from core.Formulas import formula_available

    # 小工具们
    from core.Utils import *

    # python的绝对路径
    # python3 = sys.executable.replace('\\','/')
    # 被占用的变量名 # 1.7.7
    occupied_variable_name = open('./media/occupied_variable_name.list','r',encoding='utf8').read().split('\n')

    # 可以<set:keyword>动态调整的全局变量
    dynamic_globals = {
        #默认切换效果（立绘）
        'am_method_default' : '<replace=0>',
        #默认切换效果持续时间（立绘）
        'am_dur_default' : 10,
        #默认切换效果（文本框）
        'bb_method_default' : '<replace=0>',
        #默认切换效果持续时间（文本框）
        'bb_dur_default' : 10,
        #默认切换效果（背景）
        'bg_method_default' : '<replace=0>',
        #默认切换效果持续时间（背景）
        'bg_dur_default' : 10,
        #默认文本展示方式
        'tx_method_default' : '<all=0>',
        #默认单字展示时间参数
        'tx_dur_default' : 5,
        #语速，单位word per minute
        'speech_speed' : 220,
        #默认的曲线函数
        'formula' : linear,
        # 星标音频的句间间隔 a1.4.3，单位是帧，通过处理delay
        'asterisk_pause' : 20,
        # a 1.8.8 次要立绘的默认透明度
        'secondary_alpha' : 60,
        # 对话行内指定的方法的应用对象：animation、bubble、both、none
        'inline_method_apply' : 'both'
    }

    # 其他函数定义

    # 解析对话行 []
    def get_dialogue_arg(text):
        try:
            cr,cre,ts,tse,se = RE_dialogue.findall(text)[0]
        except IndexError:
            raise ParserError('UnableDial')
        this_duration = int(len(ts)/(dynamic_globals['speech_speed']/60/frame_rate))
        this_charactor = RE_characor.findall(cr)
        # 切换 method
        if (cre=='') | (dynamic_globals['inline_method_apply']=='none'): # 没有指定，或者禁用指定，都走默认值
            am_method,am_dur = RE_modify.findall(dynamic_globals['am_method_default'])[0]
            bb_method,bb_dur = RE_modify.findall(dynamic_globals['bb_method_default'])[0]
        elif dynamic_globals['inline_method_apply']=='animation': # 有指定，参照inline_method_apply
            am_method,am_dur = RE_modify.findall(cre)[0]
            bb_method,bb_dur = RE_modify.findall(dynamic_globals['bb_method_default'])[0]
        elif dynamic_globals['inline_method_apply']=='bubble':
            am_method,am_dur = RE_modify.findall(dynamic_globals['am_method_default'])[0]
            bb_method,bb_dur = RE_modify.findall(cre)[0]
        elif dynamic_globals['inline_method_apply']=='both':
            am_method,am_dur = RE_modify.findall(cre)[0]
            bb_method,bb_dur = am_method,am_dur
        # 切换 dur
        if am_dur == '':# 没有指定 走默认值
            am_dur = dynamic_globals['am_dur_default']
        else: # 有指定，走指定值
            am_dur = int(am_dur.replace('=',''))
        if bb_dur == '':
            bb_dur = dynamic_globals['bb_dur_default']
        else:
            bb_dur = int(bb_dur.replace('=',''))
        # 文本显示 method
        if tse=='':
            tse = dynamic_globals['tx_method_default']
        text_method,text_dur = RE_modify.findall(tse)[0] #<black=\d+> 
        # 文本显示 dur
        if text_dur == '':
            text_dur = dynamic_globals['tx_dur_default']
        else:
            text_dur = int(text_dur.replace('=',''))
        # 语音和音效参数
        if se == '':
            this_sound = []
        else:
            this_sound = RE_sound.findall(se)

        return (this_charactor,this_duration,am_method,am_dur,bb_method,bb_dur,ts,text_method,text_dur,this_sound)

    # 解析背景、立绘、气泡行 <background><animation><bubble>
    def get_placeobj_arg(text):
        try:
            obj_type,obje,objc = RE_placeobj.findall(text)[0]
        except IndexError:
            raise ParserError('UnablePlace')
        if obje=='':
            if obj_type == 'background':
                obje = dynamic_globals['bg_method_default']
            elif obj_type == 'bubble':
                obje = dynamic_globals['bb_method_default']
            else: # obj_type == 'animation'
                obje = dynamic_globals['am_method_default']
        method,method_dur = RE_modify.findall(obje)[0]
        if method_dur == '':
            if obj_type == 'background':
                method_dur = dynamic_globals['bg_dur_default']
            elif obj_type == 'bubble':
                method_dur = dynamic_globals['bb_dur_default']
            else: # obj_type == 'animation'
                method_dur = dynamic_globals['am_dur_default']
        else:
            method_dur = int(method_dur.replace('=',''))
        return (objc,method,method_dur)

    # 解释设置行 <set:>
    def get_seting_arg(text):
        try:
            target,args = RE_setting.findall(text)[0]
        except IndexError:
            raise ParserError('UnableSet')
        return (target,args)

    # 处理am和bb类的动态切换效果
    def ambb_methods(method_name,method_dur,this_duration,i):
        def dynamic(scale,duration,balance,cut,enable): # 动态(尺度,持续,平衡,进出,启用)
            if enable == True: # cutin=1,cutout=0
                if cut == balance:
                    return dynamic_globals['formula'](0,scale,duration)
                else:
                    return dynamic_globals['formula'](scale,0,duration)
            else: # enable == False:
                return np.ones(duration)*scale*balance
        if method_dur == 0:
            return np.ones(this_duration),'NA'
        method_keys = method_name.split('_')
        method_args = {'alpha':'replace','motion':'static','direction':'up','scale':'major','cut':'both'} #default
        scale_dic = {'major':0.3,'minor':0.12,'entire':1.0}
        direction_dic = {'up':0,'down':180,'left':90,'right':270} # up = 0 剩下的逆时针
        # parse method name
        for key in method_keys:
            if key in ['black','replace','delay']:
                method_args['alpha'] = key
            elif key in ['pass','leap','static','circular']:
                method_args['motion'] = key
            elif key in ['up','down','left','right']:
                method_args['direction'] = key
            elif key in ['major','minor','entire']:
                method_args['scale'] = key
            elif key in ['in','out','both']:
                method_args['cut'] = key
            elif 'DG' == key[0:2]:
                try:
                    method_args['direction'] = float(key[2:])
                except Exception:
                    raise ParserError('SwitchDial',method_name,str(i+1))
            else:
                try:
                    method_args['scale'] = int(key)
                except Exception:
                    raise ParserError('SwitchDial',method_name,str(i+1))
        # 切入，切出，或者双端
        cutin,cutout ={'in':(1,0),'out':(0,1),'both':(1,1)}[method_args['cut']]
        # alpha
        if method_args['alpha'] == 'replace': #--
            alpha_timeline = np.hstack(np.ones(this_duration)) # replace的延后功能撤销！
        elif method_args['alpha'] == 'delay': #_-
            alpha_timeline = np.hstack([np.zeros(method_dur),np.ones(this_duration-method_dur)]) # 延后功能
        else: # method_args['alpha'] == 'black':#>1<
            alpha_timeline = np.hstack([dynamic(1,method_dur,1,1,cutin),np.ones(this_duration-2*method_dur),dynamic(1,method_dur,1,0,cutout)])
        # static 的提前终止
        if method_args['motion'] == 'static':
            pos_timeline = 'NA'
            return alpha_timeline,pos_timeline
        
        # direction
        try:
            theta = np.deg2rad(direction_dic[method_args['direction']])
        except Exception: # 设定为角度
            theta = np.deg2rad(method_args['direction'])
        # scale
        if method_args['scale'] in ['major','minor','entire']: #上下绑定屏幕高度，左右绑定屏幕宽度*scale_dic[method_args['scale']]
            method_args['scale'] = ((np.cos(theta)*Height)**2+(np.sin(theta)*Width)**2)**(1/2)*scale_dic[method_args['scale']]
        else: # 指定了scale
            pass
        # motion
        if method_args['motion'] == 'pass': # >0>
            D1 = np.hstack([dynamic(method_args['scale']*np.sin(theta),method_dur,0,1,cutin),
                            np.zeros(this_duration-2*method_dur),
                            dynamic(-method_args['scale']*np.sin(theta),method_dur,0,0,cutout)])
            D2 = np.hstack([dynamic(method_args['scale']*np.cos(theta),method_dur,0,1,cutin),
                            np.zeros(this_duration-2*method_dur),
                            dynamic(-method_args['scale']*np.cos(theta),method_dur,0,0,cutout)])
        elif method_args['motion'] == 'leap': # >0<
            D1 = np.hstack([dynamic(method_args['scale']*np.sin(theta),method_dur,0,1,cutin),
                            np.zeros(this_duration-2*method_dur),
                            dynamic(method_args['scale']*np.sin(theta),method_dur,0,0,cutout)])
            D2 = np.hstack([dynamic(method_args['scale']*np.cos(theta),method_dur,0,1,cutin),
                            np.zeros(this_duration-2*method_dur),
                            dynamic(method_args['scale']*np.cos(theta),method_dur,0,0,cutout)])
        # 实验性质的功能，想必不可能真的有人用这么鬼畜的效果吧
        elif method_args['motion'] == 'circular': 
            theta_timeline = (
                np
                .repeat(dynamic_globals['formula'](0-theta,2*np.pi-theta,method_dur),np.ceil(this_duration/method_dur).astype(int))
                .reshape(method_dur,np.ceil(this_duration/method_dur).astype(int))
                .transpose().ravel())[0:this_duration]
            D1 = np.sin(theta_timeline)*method_args['scale']
            D2 = -np.cos(theta_timeline)*method_args['scale']
        else:
            pos_timeline = 'NA'
            return alpha_timeline,pos_timeline
        pos_timeline = concat_xy(D1,D2)
        return alpha_timeline,pos_timeline

    # 解析函数
    def parser(stdin_text):
        # section:小节号, BG: 背景，Am：立绘，Bb：气泡，BGM：背景音乐，Voice：语音，SE：音效
        render_arg = [
        'section',
        'BG1','BG1_a','BG1_c','BG1_p','BG2','BG2_a','BG2_c','BG2_p',
        'Am1','Am1_t','Am1_a','Am1_c','Am1_p','Am2','Am2_t','Am2_a','Am2_c','Am2_p','Am3','Am3_t','Am3_a','Am3_c','Am3_p',
        'AmS','AmS_t','AmS_a','AmS_c','AmS_p',
        'Bb','Bb_main','Bb_header','Bb_a','Bb_c','Bb_p',
        'BbS','BbS_main','BbS_header','BbS_a','BbS_c','BbS_p',
        'BGM','Voice','SE'
        ]
        # 断点文件
        break_point = pd.Series(0,index=range(0,len(stdin_text)),dtype=int)
        # break_point[0]=0
        # 视频+音轨 时间轴
        render_timeline = pd.DataFrame(dtype=str,columns=render_arg)
        BGM_queue = []
        # 当前背景、放置立绘、放置气泡
        this_background = "black"
        last_placed_animation_section = 0
        this_placed_animation = ('NA','replace',0,'NA') # am,method,method_dur,center
        last_placed_bubble_section = 0
        this_placed_bubble = ('NA','replace',0,'','','all',0,'NA') # bb,method,method_dur,HT,MT,tx_method,tx_dur,center
        # 内建的媒体，主要指BIA
        bulitin_media = {}

        for i,text in enumerate(stdin_text):
            # 空白行
            if text == '':
                break_point[i+1]=break_point[i]
                continue
            # 注释行 格式： # word
            elif text[0] == '#':
                break_point[i+1]=break_point[i]
                continue
            # 对话行 格式： [角色1,角色2(30).happy]<replace=30>:巴拉#巴拉#巴拉<w2w=1>
            elif (text[0] == '[') & (']' in text):
                try:
                    # 从ts长度预设的 this_duration
                    this_charactor,this_duration,am_method,am_dur,bb_method,bb_dur,ts,text_method,text_dur,this_sound = get_dialogue_arg(text)
                    # a 1.3 从音频中加载持续时长 {SE1;*78} 注意，这里只需要载入星标时间，检查异常不在这里做：
                    asterisk_timeset = RE_asterisk.findall('\t'.join(this_sound)) #在音频标志中读取
                    if len(asterisk_timeset) == 0:  #没检测到星标
                        pass
                    elif len(asterisk_timeset) == 1: #检查到一个星标
                        try:
                            asterisk_time = float(asterisk_timeset[0][-1]) #取第二个，转化为浮点数
                            this_duration = dynamic_globals['asterisk_pause'] + np.ceil((asterisk_time)*frame_rate).astype(int) # a1.4.3 添加了句间停顿
                        except Exception:
                            print(WarningPrint('FailAster',str(i+1)))
                    else: #检测到复数个星标
                        raise ParserError('2muchAster',str(i+1))

                    # 确保时长不短于切换特效时长
                    if this_duration<(2*max(am_dur,bb_dur)+1):
                        this_duration = 2*max(am_dur,bb_dur)+1

                    # 建立本小节的timeline文件
                    this_timeline=pd.DataFrame(index=range(0,this_duration),dtype=str,columns=render_arg)
                    this_timeline['BG2'] = this_background
                    this_timeline['BG2_a'] = 100
                    # 载入切换效果
                    alpha_timeline_A,pos_timeline_A = ambb_methods(am_method,am_dur,this_duration,i)
                    alpha_timeline_B,pos_timeline_B = ambb_methods(bb_method,bb_dur,this_duration,i)
                    #各个角色：
                    if len(this_charactor) > 3:
                        raise ParserError('2muchChara',str(i+1))
                    for k,charactor in enumerate(this_charactor[0:3]):
                        name,alpha,subtype= charactor
                        # 处理空缺参数
                        if subtype == '':
                            subtype = '.default'
                        if alpha == '':
                            alpha = -1
                        else:
                            alpha = int(alpha[1:-1])
                        # 在角色表中找到指定角色 this_char_series -> pd.Series
                        try:
                            this_char_series = charactor_table.loc[name+subtype]
                        except KeyError as E: # 在角色表里面找不到name，raise在这里！
                            raise ParserError('UndefName',name+subtype,str(i+1),E)
                        # 如果index存在重复值，则this_char_series不是一个 Series # 在这里处理的角色表index重复值，之后不再考虑这个异常
                        if type(this_char_series) is not pd.Series:
                            raise ParserError('DupSubtype',name+subtype)
                        
                        # 立绘的参数
                        this_am = this_char_series['Animation']
                        this_timeline['Am'+str(k+1)] = this_am                        
                        # 动画帧的参数（tick）
                        if (this_am!=this_am) | (this_am=='NA'):# this_am 可能为空的，需要先处理这种情况！
                            this_timeline['Am'+str(k+1)+'_t'] = 0
                            this_timeline['Am'+str(k+1)+'_c'] = 'NA'
                        else:
                            try:
                                this_timeline['Am'+str(k+1)+'_t'] = eval('{am}.get_tick({dur})'.format(am=this_am,dur=this_duration))
                                this_timeline['Am'+str(k+1)+'_c'] = str(eval(this_am+'.pos'))
                            except NameError as E: # 指定的am没有定义！
                                raise ParserError('UndefAnime', this_am, name+subtype)
                        # 透明度参数（alpha）
                        if (alpha >= 0)&(alpha <= 100): # alpha 1.8.8 如果有指定合法的透明度，则使用指定透明度
                            this_timeline['Am'+str(k+1)+'_a']=alpha_timeline_A*alpha
                        else: # 如果没有指定透明度
                            if k == 0: # 如果是首要角色，透明度为100
                                this_timeline['Am'+str(k+1)+'_a']=alpha_timeline_A*100
                            else: # 如果是次要角色，透明度为secondary_alpha，默认值60
                                this_timeline['Am'+str(k+1)+'_a']=alpha_timeline_A*dynamic_globals['secondary_alpha'] 
                        # 位置参数（pos)
                        this_timeline['Am'+str(k+1)+'_p'] = pos_timeline_A
                        # 气泡的参数
                        if k == 0:
                            this_bb = this_char_series['Bubble']
                            # 主要角色一定要有bubble！，次要的可用没有
                            if (this_bb!=this_bb) | (this_bb=='NA'):
                                raise ParserError('CharaNoBb',name+subtype,str(i+1))
                            # 获取目标的头文本
                            try:
                                # 存在:分隔，说明是聊天窗类，始终取:前面的内容识别为气泡
                                if ':' in this_bb:
                                    chatwindow_key = this_bb.split(':')[1]
                                    this_bb = this_bb.split(':')[0]
                                    # 聊天窗类的target采用子气泡的target
                                    bubble_obj = eval(this_bb)
                                    try:
                                        targets = bubble_obj.sub_Bubble[chatwindow_key].target
                                    except KeyError as E: # 指定的Key不存在！
                                        raise ParserError('InvalidKey', chatwindow_key, this_bb)
                                else:
                                    bubble_obj = eval(this_bb)
                                    if type(bubble_obj) is ChatWindow:
                                        # targets = bubble_obj.target ; AttributeError: 'ChatWindow' object has no attribute 'target'
                                        raise ParserError('CWUndepend', this_bb)
                                    elif type(bubble_obj) in [Bubble,Balloon,DynamicBubble]:
                                        targets = bubble_obj.target
                                    else:
                                        raise ParserError('NotBubble', this_bb, name+subtype)
                                # Bubble,DynamicBubble类：只有一个头文本
                                if type(bubble_obj) in [Bubble,DynamicBubble]:
                                    target_text = this_char_series[targets]
                                # Balloon 类：有若干个头文本，targets是一个list,用 | 分隔
                                elif type(bubble_obj) is Balloon:
                                    target_text = '|'.join(this_char_series[targets].values)
                                # ChatWindow 类：只有一个头文本，头文本不能包含|和#，还需要附上key
                                elif type(bubble_obj) is ChatWindow:
                                    if ('|' in this_char_series[targets]) | ('#' in this_char_series[targets]):
                                        raise ParserError('InvSymbpd',name+subtype)
                                    else:
                                        target_text = chatwindow_key+'#'+this_char_series[targets]
                                else:
                                    # raise NameError('Media object "' + this_bb + '" is not a Bubble!')
                                    raise ParserError('NotBubble', this_bb, name+subtype)
                            except NameError as E: # 指定的bb没有定义！
                                raise ParserError('UndefBubble', this_bb, name+subtype)
                            except KeyError as E: # 指定的target不存在！
                                raise ParserError('TgNotExist', E, this_bb)
                            # 针对文本内容的警告和报错
                            try:
                                this_line_limit = bubble_obj.MainText.line_limit
                            except AttributeError: # 'NoneType' object has no attribute 'line_limit'
                                if type(bubble_obj) is ChatWindow:
                                    this_line_limit = bubble_obj.sub_Bubble[chatwindow_key].MainText.line_limit
                                else:
                                    raise ParserError('MissMainTx',this_bb)
                            # ts或者target_text里面有非法字符，双引号，反斜杠
                            if ('"' in target_text) | ('\\' in target_text) | ('"' in ts) | ('\\' in ts):
                                raise ParserError('InvSymbqu',str(i+1))
                            # 未声明手动换行
                            if ('#' in ts)&(ts[0]!='^'):
                                ts = '^' + ts # 补齐申明符号
                                print(WarningPrint('UndeclMB',str(i+1)))
                            #行数过多的警告
                            if (len(ts)>this_line_limit*4) | (len(ts.split('#'))>4):
                                print(WarningPrint('More4line',str(i+1)))
                            # 手动换行的字数超限的警告
                            if ((ts[0]=='^')|('#' in ts))&(np.frompyfunc(len,1,1)(ts.replace('^','').split('#')).max()>this_line_limit):
                                print(WarningPrint('MBExceed',str(i+1)))
                            # 赋值给当前时间轴的Bb轨道
                            this_timeline['Bb'] = this_bb
                            this_timeline['Bb_main'] = ts
                            this_timeline['Bb_header'] = target_text
                            this_timeline['Bb_a'] = alpha_timeline_B*100
                            this_timeline['Bb_p'] = pos_timeline_B
                            this_timeline['Bb_c'] = str(eval(this_bb+'.pos'))

                    # 文字显示的参数
                    if text_method == 'all':
                        if text_dur == 0:
                            pass
                        else:
                            this_timeline.loc[0:text_dur,'Bb_main'] = '' #将前n帧的文本设置为空白
                    elif text_method == 'w2w':
                        word_count_timeline = np.arange(0,this_duration,1)//text_dur+1
                        this_timeline['Bb_main'] = UF_cut_str(this_timeline['Bb_main'],word_count_timeline)
                    elif text_method == 'l2l': 
                        if ((ts[0]=='^')|('#' in ts)): #如果是手动换行的列
                            word_count_timeline = get_l2l(ts,text_dur,this_duration) # 不保证稳定呢！
                        else:
                            line_limit = eval(this_timeline['Bb'][1]+'.MainText.line_limit') #获取主文本对象的line_limit参数 # 为什么是【1】？？
                            word_count_timeline = (np.arange(0,this_duration,1)//(text_dur*line_limit)+1)*line_limit
                        this_timeline['Bb_main'] = UF_cut_str(this_timeline['Bb_main'],word_count_timeline)
                    else:
                        raise ParserError('UnrecTxMet', text_method, str(i+1))
                    # 如果是ChatWindow
                    if type(bubble_obj) is ChatWindow:
                        # 记录本次需要添加的文本（最后一帧）
                        maintext_end = this_timeline['Bb_main'].values[-1]
                        header_end = this_timeline['Bb_header'].values[-1]
                        this_timeline['Bb_main'].values[-1]
                        this_timeline['Bb_header'].values[-1]
                        # 更新timeline对象，追加历史记录
                        this_timeline['Bb_header'] = bubble_obj.UF_add_header_text(this_timeline['Bb_header'])
                        this_timeline['Bb_main'] = bubble_obj.UF_add_main_text(this_timeline['Bb_main'])
                        # 更新bubble对象的历史记录
                        bubble_obj.append(maintext_end,header_end)
                    #音频信息
                    for sound in this_sound: #this_sound = ['{SE_obj;30}','{SE_obj;30}']
                        try:
                            se_obj,delay = sound[1:-1].split(';')#sound = '{SE_obj;30}'# 由于这个地方，音频框的分隔符号只能用分号
                        except Exception: # #sound = '{SE_obj}'
                            delay = '0'
                            se_obj = sound[1:-1] # 去掉花括号
                        if delay == '':
                            delay = 0
                        elif '*' in delay: # 如果是星标时间 delay 是asterisk_pause的一半
                            delay = int(dynamic_globals['asterisk_pause']/2)
                        elif int(delay) >= this_duration: # delay 不能比一个单元还长
                            delay = this_duration-1
                        else:
                            delay = int(delay)
                        if '*' in se_obj:
                            raise ParserError('UnpreAster', str(i+1))
                        if se_obj in media_list: # 如果delay在媒体里已经定义，则视为SE
                            this_timeline.loc[delay,'SE'] = se_obj
                        elif os.path.isfile(se_obj[1:-1]) == True: #或者指向一个确定的文件，则视为语音
                            this_timeline.loc[delay,'Voice'] = se_obj
                        elif se_obj in ['NA','']: # 如果se_obj是空值或NA，则什么都不做 alpha1.8.5
                            pass
                        else:
                            raise ParserError('SEnotExist', se_obj, str(i+1))
                    # BGM
                    if BGM_queue != []:
                        this_timeline.loc[0,'BGM'] = BGM_queue.pop(0) #从BGM_queue里取第一个出来 alpha 1.13.5
                    # 时间轴延长
                    this_timeline['section'] = i
                    break_point[i+1]=break_point[i]+this_duration
                    this_timeline.index = range(break_point[i],break_point[i+1])
                    render_timeline = pd.concat([render_timeline,this_timeline],axis=0)
                    continue
                except Exception as E:
                    print(E)
                    raise ParserError('ParErrDial', str(i+1))
            # 背景设置行，格式： <background><black=30>:BG_obj
            elif text[0:12] == '<background>':
                try:
                    bgc,method,method_dur = get_placeobj_arg(text)
                    if bgc in media_list: # 检查是否是已定义的对象
                        next_background=bgc
                    else:
                        raise ParserError('UndefBackGd',bgc,str(i+1))
                    if method=='replace': #replace 改为立刻替换 并持续n秒
                        this_timeline=pd.DataFrame(index=range(0,method_dur),dtype=str,columns=render_arg)
                        this_timeline['BG2']=next_background
                        this_timeline['BG2_a']=100
                        this_timeline['BG2_c']=str(eval(next_background+'.pos'))
                    elif method=='delay': # delay 等价于原来的replace，延后n秒，然后替换
                        this_timeline=pd.DataFrame(index=range(0,method_dur),dtype=str,columns=render_arg)
                        this_timeline['BG2']=this_background
                        this_timeline['BG2_a']=100
                        this_timeline['BG2_c']=str(eval(this_background+'.pos'))
                    # 'black','white'
                    elif method in ['black','white']:
                        this_timeline=pd.DataFrame(index=range(0,method_dur),dtype=str,columns=render_arg)
                        # 下图层BG2，前半程是旧图层，后半程是新图层，透明度均为100
                        this_timeline.loc[:(method_dur//2),'BG2'] = this_background
                        this_timeline.loc[(method_dur//2):,'BG2'] = next_background
                        this_timeline.loc[:(method_dur//2),'BG2_c']=str(eval(this_background+'.pos'))
                        this_timeline.loc[(method_dur//2):,'BG2_c']=str(eval(next_background+'.pos'))
                        this_timeline['BG2_a'] = 100
                        # 上图层BG1，是指定的颜色，透明度是100-abs(formula(100,-100,dur))
                        this_timeline['BG1'] = method
                        this_timeline['BG1_c']='(0,0)'
                        this_timeline['BG1_a']=100-np.abs(dynamic_globals['formula'](-100,100,method_dur))
                        pass
                    elif method in ['cross','push','cover']: # 交叉溶解，黑场，白场，推，覆盖
                        this_timeline=pd.DataFrame(index=range(0,method_dur),dtype=str,columns=render_arg)
                        this_timeline['BG1']=next_background
                        this_timeline['BG1_c']=str(eval(next_background+'.pos'))
                        this_timeline['BG2']=this_background
                        this_timeline['BG2_c']=str(eval(this_background+'.pos'))
                        if method == 'cross':
                            this_timeline['BG1_a']=dynamic_globals['formula'](0,100,method_dur)
                            this_timeline['BG2_a']=100
                        elif method in ['push','cover']:
                            this_timeline['BG1_a']=100
                            this_timeline['BG2_a']=100
                            if method == 'push': # 新背景从右侧把旧背景推出去
                                this_timeline['BG1_p'] = concat_xy(dynamic_globals['formula'](Width,0,method_dur),np.zeros(method_dur))
                                this_timeline['BG2_p'] = concat_xy(dynamic_globals['formula'](0,-Width,method_dur),np.zeros(method_dur))
                            else: #cover 新背景从右侧进来叠在原图上面
                                this_timeline['BG1_p'] = concat_xy(dynamic_globals['formula'](Width,0,method_dur),np.zeros(method_dur))
                                this_timeline['BG2_p'] = 'NA'
                    else:
                        raise ParserError('SwitchBkGd',method,str(i+1))
                    this_background = next_background #正式切换背景
                    # BGM
                    if BGM_queue != []:
                        this_timeline.loc[0,'BGM'] = BGM_queue.pop(0)                
                    # 时间轴延长
                    this_timeline['section'] = i
                    break_point[i+1]=break_point[i]+len(this_timeline.index)
                    this_timeline.index = range(break_point[i],break_point[i+1])
                    render_timeline = pd.concat([render_timeline,this_timeline],axis=0)
                    continue
                except Exception as E:
                    print(E)
                    raise ParserError('ParErrBkGd',str(i+1))
            # 常驻立绘设置行，格式：<animation><black=30>:(Am_obj,Am_obj2)
            elif text[0:11] == '<animation>':
                # 处理上一次的
                last_placed_index = range(break_point[last_placed_animation_section],break_point[i])
                this_duration = len(last_placed_index)
                this_am,am_method,am_dur,am_center = this_placed_animation
                # 如果place的this_duration小于切换时间，则清除动态切换效果
                if (this_duration<(2*am_dur+1)) & (this_am != 'NA'):
                    print(WarningPrint('PAmMetDrop'))
                    am_dur = 0
                    am_method = 'replace'
                render_timeline.loc[last_placed_index,'AmS'] = this_am
                # this_am 可能为空的，需要先处理这种情况！
                if (this_am!=this_am) | (this_am=='NA'):
                    render_timeline.loc[last_placed_index,'AmS_t'] = 0
                    render_timeline.loc[last_placed_index,'AmS_a'] = 0
                    render_timeline.loc[last_placed_index,'AmS_c'] = 'NA'
                    render_timeline.loc[last_placed_index,'AmS_p'] = 'NA'
                else:
                    alpha_timeline_A,pos_timeline_A = ambb_methods(am_method,am_dur,this_duration,i)
                    render_timeline.loc[last_placed_index,'AmS_a'] = alpha_timeline_A*100
                    render_timeline.loc[last_placed_index,'AmS_p'] = pos_timeline_A
                    render_timeline.loc[last_placed_index,'AmS_t'] = eval('{am}.get_tick({dur})'.format(am=this_am,dur=this_duration))
                    render_timeline.loc[last_placed_index,'AmS_c'] = am_center
                # 获取本次的
                try:
                    amc,method,method_dur = get_placeobj_arg(text)
                    # 获取立绘列表，检查立绘是否定义
                    if (amc[0] == '(') and (amc[-1] == ')'):
                        amc_list = amc[1:-1].split(',')
                        grouped_ampos = []
                        for amo in amc_list:
                            # 检验指定的名称是否是Animation
                            if amo not in media_list:
                                raise ParserError('UndefPAnime',amo,str(i+1))
                            else:
                                grouped_ampos.append(str(eval(amo).pos))
                        # 新建GA
                        Auto_media_name = 'BIA_'+str(i+1)
                        code_to_run = 'global {media_name} ;{media_name} = GroupedAnimation(subanimation_list={subanime},subanimation_current_pos={animepos})'
                        code_to_run = code_to_run.format(media_name=Auto_media_name,subanime='['+','.join(amc_list)+']',animepos='['+','.join(grouped_ampos)+']')
                        # print(code_to_run)
                        # 执行
                        exec(code_to_run)
                        # 添加到media_list和bulitin_media
                        media_list.append(Auto_media_name)
                        bulitin_media[Auto_media_name] = code_to_run
                        # 标记为下一次
                        this_placed_animation = (Auto_media_name,method,method_dur,'(0,0)') # 因为place的应用是落后于设置的，因此需要保留c参数！
                        last_placed_animation_section = i
                    # 只有一个立绘
                    elif amc in media_list:
                        if type(eval(amc)) in [Animation,BuiltInAnimation,GroupedAnimation]:
                            this_placed_animation = (amc,method,method_dur,str(eval(amc).pos))
                            last_placed_animation_section = i
                        else: # 如果type 不是 Animation 类，也 UndefPAnime
                            raise ParserError('UndefPAnime',amc,str(i+1))
                    # 取消place立绘
                    elif amc == 'NA':
                        this_placed_animation = ('NA','replace',0,'(0,0)')
                        last_placed_animation_section = i
                    else:
                        raise ParserError('UndefPAnime',amc,str(i+1))
                except Exception as E:
                    print(E)
                    raise ParserError('ParErrAnime',str(i+1))
            # 常驻气泡设置行，格式：<bubble><black=30>:Bubble_obj("Header_text","Main_text",<text_method>)
            elif text[0:8] == '<bubble>':
                # 处理上一次的
                last_placed_index = range(break_point[last_placed_bubble_section],break_point[i])
                this_duration = len(last_placed_index)
                # bb,method,method_dur,HT,MT,text_method,tx_dur,center
                this_bb,bb_method,bb_dur,this_hd,this_tx,text_method,text_dur,bb_center = this_placed_bubble
                # 如果place的this_duration小于切换时间，则清除动态切换效果
                if (this_duration<(2*bb_dur+1)) & (this_bb != 'NA'):
                    print(WarningPrint('PBbMetDrop'))
                    bb_dur = 0
                    bb_method = 'replace'
                # 'BbS','BbS_main','BbS_header','BbS_a','BbS_c','BbS_p',
                render_timeline.loc[last_placed_index,'BbS'] = this_bb
                # this_bb 可能为空的，需要先处理这种情况！
                if (this_bb!=this_bb) | (this_bb=='NA'):
                    render_timeline.loc[last_placed_index,'BbS_main'] = ''
                    render_timeline.loc[last_placed_index,'BbS_header'] = ''
                    render_timeline.loc[last_placed_index,'BbS_a'] = 0
                    render_timeline.loc[last_placed_index,'BbS_c'] = 'NA'
                    render_timeline.loc[last_placed_index,'BbS_p'] = 'NA'
                else:
                    # 
                    alpha_timeline_B,pos_timeline_B = ambb_methods(bb_method,bb_dur,this_duration,i)
                    render_timeline.loc[last_placed_index,'BbS_a'] = alpha_timeline_B*100
                    render_timeline.loc[last_placed_index,'BbS_c'] = bb_center
                    render_timeline.loc[last_placed_index,'BbS_p'] = pos_timeline_B
                    render_timeline.loc[last_placed_index,'BbS_main'] = this_tx
                    render_timeline.loc[last_placed_index,'BbS_header'] = this_hd
                    # 文字显示的参数
                    if text_method == 'all':
                        if text_dur == 0:
                            pass
                        else:
                            # 将前n帧的文本设置为空白
                            render_timeline.loc[last_placed_index[0]:(last_placed_index[0]+text_dur),'BbS_main'] = ''
                    elif text_method == 'w2w':
                        word_count_timeline = np.arange(0,this_duration,1)//text_dur+1
                        render_timeline.loc[last_placed_index,'BbS_main'] = UF_cut_str(render_timeline.loc[last_placed_index,'BbS_main'],word_count_timeline)
                    elif text_method == 'l2l': 
                        if ((this_tx[0]=='^')|('#' in this_tx)): #如果是手动换行的列
                            word_count_timeline = get_l2l(this_tx,text_dur,this_duration) # 不保证稳定呢！
                        else:
                            line_limit = eval(this_bb+'.MainText.line_limit') #获取主文本对象的line_limit参数
                            word_count_timeline = (np.arange(0,this_duration,1)//(text_dur*line_limit)+1)*line_limit
                        render_timeline.loc[last_placed_index,'BbS_main'] = UF_cut_str(render_timeline.loc[last_placed_index,'BbS_main'],word_count_timeline)
                    else:
                        pass
                # 获取本次的
                try:
                    # type: str,str,int
                    bbc,method,method_dur = get_placeobj_arg(text)
                    # 如果是设置为NA
                    if bbc == 'NA':
                        # bb,method,method_dur,HT,MT,tx_method,tx_dur,center
                        this_placed_bubble = ('NA','replace',0,'','','all',0,'NA')
                        last_placed_bubble_section = i
                    # 如果是一个合法的Bubble表达式
                    else:
                        try:
                            this_bb,this_hd,this_tx,this_method_label,this_tx_method,this_tx_dur = RE_bubble.findall(bbc)[0]
                            # 检查Bubble类媒体的可用性
                            if this_bb not in media_list:
                                raise NameError(this_bb)
                            elif type(eval(this_bb)) not in [Bubble,Balloon,DynamicBubble,ChatWindow]:
                                raise NameError(this_bb)
                            else:
                                pass
                            # 检查，tx_method 的合法性
                            # 缺省文字效果
                            if this_method_label == '':
                                this_method_label = dynamic_globals['tx_method_default']
                                this_tx_method,this_tx_dur = RE_modify.findall(this_method_label)[0] #<black=\d+> 
                                # 直接获取下来的的 <all=0> all =0
                                this_tx_dur = this_tx_dur[1:]
                            elif this_tx_dur == '':
                                this_tx_dur = dynamic_globals['tx_dur_default']
                            # 如果是非法的
                            if this_tx_method not in ['all','w2w','l2l']:
                                raise ValueError(this_method_label)
                            else:
                                this_placed_bubble = (this_bb,method,method_dur,this_hd,this_tx,this_tx_method,int(this_tx_dur),str(eval(this_bb).pos))
                                last_placed_bubble_section = i
                        except IndexError:
                            raise ParserError('InvaPBbExp',bbc,str(i+1))
                        except ValueError: # ValueError: invalid literal for int() with base 10: 'asd'
                            raise ParserError('UnrecPBbTxM',this_method_label,str(i+1))
                        except NameError as E:
                            raise ParserError('UndefPBb',this_bb,str(i+1))
                except Exception as E:
                    print(E)
                    raise ParserError('ParErrBb',str(i+1))
            # 参数设置行，格式：<set:speech_speed>:220
            elif (text[0:5] == '<set:') & ('>:' in text):
                try:
                    target,args = get_seting_arg(text)
                    # 整数类型的变量
                    if target in ['am_dur_default','bb_dur_default','bg_dur_default','tx_dur_default','speech_speed','asterisk_pause','secondary_alpha']:
                        try: 
                            args = int(args)
                            if args < 0:
                                raise ParserError('invalid args')
                            else:
                                dynamic_globals[target] = args
                        except Exception:
                            print(WarningPrint('Set2Invalid',target,args))
                    # <method>类型的变量
                    elif target in ['am_method_default','bb_method_default','bg_method_default','tx_method_default']:
                        # exec("global {0} ; {0} = {1}".format(target,'\"'+args+'\"')) # 当作文本型，无论是啥都接受
                        dynamic_globals[target] = args
                    # BGM路径或者对象类的变量
                    elif target == 'BGM':
                        if args in media_list:
                            BGM_queue.append(args)
                        elif os.path.isfile(args[1:-1]):
                            BGM_queue.append(args)
                        elif args == 'stop':
                            BGM_queue.append(args)
                        else:
                            raise ParserError('UndefBGM',args,str(i+1))
                    # formula类型的变量
                    elif target == 'formula':
                        if args in formula_available.keys():
                            dynamic_globals['formula'] = formula_available[args]
                        elif args[0:6] == 'lambda':
                            try:
                                dynamic_globals['formula'] = eval(args)
                                print(WarningPrint('UseLambda',str(dynamic_globals['formula'](0,1,2)),str(i+1)))                          
                            except Exception:
                                raise ParserError('UnspFormula',args,str(i+1))
                        else:
                            raise ParserError('UnspFormula',args,str(i+1))
                    # 枚举类型的变量
                    elif target == 'inline_method_apply':
                        if args in ['animation','bubble','both','none']:
                            dynamic_globals['inline_method_apply'] = args
                        else:
                            print(WarningPrint('Set2Invalid',target,args))
                    # 角色表中的自定义列
                    elif '.' in target:
                        target_split = target.split('.')
                        target_column = target_split[-1]
                        # 如果目标列不存在于角色表
                        if target_column not in charactor_table.columns:
                            raise ParserError('ModUndefCol',target_column)
                        # 如果尝试修改受保护的列
                        elif target_column in ['Name','Subtype','Animation','Bubble','Voice','SpeechRate','PitchRate']:
                            raise ParserError('ModProtcCol',target_column)
                        # 如果只指定了一个角色名和列名，则变更应用于角色名下所有的subtype
                        if len(target_split) == 2:
                            name = target_split[0]
                            if (name in charactor_table['Name'].values):
                                try:
                                    charactor_table.loc[charactor_table['Name']==name,target_column] = args
                                except Exception as E:
                                    raise ParserError('ModCTError',target,E)
                            else:
                                raise ParserError('UndefTgName',name,str(i+1))
                        # 如果只指定了角色名、差分名和列名，则变更仅应用于该subtype
                        elif len(target_split) == 3:
                            name,subtype = target_split[0:2]
                            if (name+'.'+subtype in charactor_table.index):
                                try:
                                    charactor_table.loc[name+'.'+subtype, target_column] = args
                                except Exception as E:
                                    raise ParserError('ModCTError',target,E)
                            else:
                                raise ParserError('UndefTgSubt',name+'.'+subtype,str(i+1))
                        # 如果超过4个指定项目，无法解析，抛出ParserError(不被支持的参数)
                        else:
                            raise ParserError('UnsuppSet',target,str(i+1))
                    # 重定位FreePos
                    elif target in media_list:
                        if type(eval(target)) is FreePos:
                            try:
                                eval(target).set(eval(args))
                            except Exception as E:
                                raise ParserError('IvSyFrPos',args,target,E)
                        else:
                            raise ParserError('UnsuppSet',target,str(i+1))
                    # 不被支持的参数
                    else:
                        raise ParserError('UnsuppSet',target,str(i+1))
                except Exception as E:
                    print(E)
                    raise ParserError('ParErrSet',str(i+1))
            # 清除行，仅适用于ChatWindow
            elif (text[0:8] == '<clear>:'):
                clear_target_name = text[8:]
                if clear_target_name not in media_list:
                    print(WarningPrint('ClearUndef',clear_target_name))
                else:
                    clear_target_obj = eval(clear_target_name)
                    if type(clear_target_obj) is ChatWindow:
                        clear_target_obj.clear()
                    else:
                        print(WarningPrint('ClearNotCW',clear_target_name))
            # 预设动画，损失生命
            elif text[0:11] == '<hitpoint>:':
                try:
                    # 载入参数
                    name_tx,heart_max,heart_begin,heart_end = RE_hitpoint.findall(text)[0]
                    heart_max = int(heart_max)
                    heart_begin = int(heart_begin)
                    heart_end = int(heart_end)
                    # 建立小节
                    this_timeline=pd.DataFrame(index=range(0,frame_rate*4),dtype=str,columns=render_arg)
                    # 背景
                    #alpha_timeline,pos_timeline = ambb_methods('black',method_dur=frame_rate//2,this_duration=frame_rate*4,i=i)
                    alpha_timeline = np.hstack([dynamic_globals['formula'](0,1,frame_rate//2),np.ones(frame_rate*3-frame_rate//2),dynamic_globals['formula'](1,0,frame_rate)])
                    this_timeline['BG1'] = 'black' # 黑色背景
                    this_timeline['BG1_a'] = alpha_timeline * 80
                    this_timeline['BG2'] = this_background
                    this_timeline['BG2_a'] = 100
                    # 新建内建动画
                    Auto_media_name = 'BIA_'+str(i+1)
                    code_to_run = 'global {media_name}_{layer} ;{media_name}_{layer} = BuiltInAnimation(anime_type="hitpoint",anime_args=("{name}",{hmax},{hbegin},{hend}),screensize = {screensize},layer={layer})'
                    code_to_run_0 = code_to_run.format(media_name=Auto_media_name,name=name_tx,hmax='%d'%heart_max,hbegin='%d'%heart_begin,hend='%d'%heart_end,screensize=str((Width,Height)),layer='0')
                    code_to_run_1 = code_to_run.format(media_name=Auto_media_name,name=name_tx,hmax='%d'%heart_max,hbegin='%d'%heart_begin,hend='%d'%heart_end,screensize=str((Width,Height)),layer='1')
                    code_to_run_2 = code_to_run.format(media_name=Auto_media_name,name=name_tx,hmax='%d'%heart_max,hbegin='%d'%heart_begin,hend='%d'%heart_end,screensize=str((Width,Height)),layer='2')
                    exec(code_to_run_0) # 灰色框
                    exec(code_to_run_1) # 留下的血
                    exec(code_to_run_2) # 丢掉的血
                    media_list.append(Auto_media_name+'_0')
                    media_list.append(Auto_media_name+'_1')
                    media_list.append(Auto_media_name+'_2')
                    bulitin_media[Auto_media_name+'_0'] = code_to_run_0
                    bulitin_media[Auto_media_name+'_1'] = code_to_run_1
                    bulitin_media[Auto_media_name+'_2'] = code_to_run_2
                    # 动画参数
                    this_timeline['Am3'] = Auto_media_name+'_0'
                    this_timeline['Am3_a'] = alpha_timeline * 100
                    this_timeline['Am3_t'] = 0
                    this_timeline['Am3_p'] = 'NA'
                    this_timeline['Am2'] = Auto_media_name+'_1'
                    this_timeline['Am2_a'] = alpha_timeline * 100
                    this_timeline['Am2_t'] = 0
                    this_timeline['Am2_p'] = 'NA'
                    this_timeline['Am1'] = Auto_media_name+'_2'
        
                    if heart_begin > heart_end: # 掉血模式
                        this_timeline['Am1_a'] = np.hstack([dynamic_globals['formula'](0,100,frame_rate//2),
                                                            np.ones(frame_rate*2-frame_rate//2)*100,
                                                            left(100,0,frame_rate//2),
                                                            np.zeros(frame_rate*2-frame_rate//2)]) #0-0.5出现，2-2.5消失
                        this_timeline['Am1_p'] = concat_xy(np.zeros(frame_rate*4),
                                                        np.hstack([np.zeros(frame_rate*2), # 静止2秒
                                                                    left(0,-int(Height*0.3),frame_rate//2), # 半秒切走
                                                                    int(Height*0.3)*np.ones(frame_rate*2-frame_rate//2)])) #1.5秒停止
                        this_timeline['Am1_t'] = 0
                    else: # 回血模式
                        this_timeline['Am1_a'] = alpha_timeline * 100 # 跟随全局血量
                        this_timeline['Am1_p'] = 'NA' # 不移动
                        this_timeline['Am1_t'] = np.hstack([np.zeros(frame_rate*1), # 第一秒静止
                                                            np.arange(0,frame_rate,1), # 第二秒播放
                                                            np.ones(frame_rate*2)*(frame_rate-1)]) # 后两秒静止
                    # BGM
                    if BGM_queue != []:
                        this_timeline.loc[0,'BGM'] = BGM_queue.pop(0) #从BGM_queue里取出来一个 alpha 1.8.5
                    # 时间轴延长
                    this_timeline['section'] = i
                    break_point[i+1]=break_point[i]+len(this_timeline.index)
                    this_timeline.index = range(break_point[i],break_point[i+1])
                    render_timeline = pd.concat([render_timeline,this_timeline],axis=0)
                    continue
                except Exception as E:
                    print(E)
                    raise ParserError('ParErrHit',str(i+1))
            # 预设动画，骰子
            elif text[0:7] == '<dice>:':
                try:
                    # 获取参数
                    dice_args = RE_dice.findall(text[7:])
                    if len(dice_args) == 0:
                        raise ParserError('NoDice')
                    # 建立小节
                    this_timeline=pd.DataFrame(index=range(0,frame_rate*5),dtype=str,columns=render_arg) # 5s
                    # 背景
                    alpha_timeline = np.hstack([dynamic_globals['formula'](0,1,frame_rate//2),np.ones(frame_rate*4-frame_rate//2),dynamic_globals['formula'](1,0,frame_rate)])
                    this_timeline['BG1'] = 'black' # 黑色背景
                    this_timeline['BG1_a'] = alpha_timeline * 80
                    this_timeline['BG2'] = this_background
                    this_timeline['BG2_a'] = 100
                    # 新建内建动画
                    Auto_media_name = 'BIA_'+str(i+1)
                    code_to_run = 'global {media_name}_{layer} ;{media_name}_{layer} = BuiltInAnimation(anime_type="dice",anime_args={dice_args},screensize = {screensize},layer={layer})'
                    code_to_run_0 = code_to_run.format(media_name=Auto_media_name,dice_args=str(dice_args),screensize=str((Width,Height)),layer='0')
                    code_to_run_1 = code_to_run.format(media_name=Auto_media_name,dice_args=str(dice_args),screensize=str((Width,Height)),layer='1')
                    code_to_run_2 = code_to_run.format(media_name=Auto_media_name,dice_args=str(dice_args),screensize=str((Width,Height)),layer='2')
                    exec(code_to_run_0) # 描述和检定值
                    exec(code_to_run_1) # 老虎机
                    exec(code_to_run_2) # 输出结果
                    media_list.append(Auto_media_name+'_0')
                    media_list.append(Auto_media_name+'_1')
                    media_list.append(Auto_media_name+'_2')
                    bulitin_media[Auto_media_name+'_0'] = code_to_run_0
                    bulitin_media[Auto_media_name+'_1'] = code_to_run_1
                    bulitin_media[Auto_media_name+'_2'] = code_to_run_2
                    # 动画参数0
                    this_timeline['Am3'] = Auto_media_name+'_0'
                    this_timeline['Am3_a'] = alpha_timeline * 100
                    this_timeline['Am3_t'] = 0
                    this_timeline['Am3_p'] = 'NA'
                    # 1
                    this_timeline['Am2'] = np.hstack([np.repeat(Auto_media_name+'_1',int(frame_rate*2.5)),np.repeat('NA',frame_rate*5-int(frame_rate*2.5))]) # 2.5s
                    this_timeline['Am2_a'] = np.hstack([dynamic_globals['formula'](0,100,frame_rate//2),
                                                        np.ones(int(frame_rate*2.5)-2*(frame_rate//2))*100,
                                                        dynamic_globals['formula'](100,0,frame_rate//2),
                                                        np.zeros(frame_rate*5-int(frame_rate*2.5))])
                    this_timeline['Am2_t'] = np.hstack([np.arange(0,int(frame_rate*2.5)),np.zeros(frame_rate*5-int(frame_rate*2.5))])
                    this_timeline['Am2_p'] = 'NA'
                    # 2
                    this_timeline['Am1'] = np.hstack([np.repeat('NA',frame_rate*5-int(frame_rate*2.5)),np.repeat(Auto_media_name+'_2',int(frame_rate*2.5))])
                    this_timeline['Am1_a'] = np.hstack([np.zeros(frame_rate*5-int(frame_rate*2.5)),
                                                        dynamic_globals['formula'](0,100,frame_rate//2),
                                                        np.ones(int(frame_rate*2.5)-frame_rate//2-frame_rate)*100,
                                                        dynamic_globals['formula'](100,0,frame_rate)])
                    this_timeline['Am1_t'] = 0
                    this_timeline['Am1_p'] = 'NA'
                    # SE
                    this_timeline.loc[frame_rate//3,'SE'] = "'./media/SE_dice.wav'"
                    # BGM
                    if BGM_queue != []:
                        this_timeline.loc[0,'BGM'] = BGM_queue.pop(0) #从BGM_queue里取第一个出来 alpha 1.13.5
                    # 时间轴延长
                    this_timeline['section'] = i
                    break_point[i+1]=break_point[i]+len(this_timeline.index)
                    this_timeline.index = range(break_point[i],break_point[i+1])
                    render_timeline = pd.concat([render_timeline,this_timeline],axis=0)
                    continue
                except Exception as E:
                    print(E)
                    raise ParserError('ParErrDice',str(i+1))
            # 异常行，报出异常
            else:
                raise ParserError('UnrecLine',str(i+1))
            break_point[i+1]=break_point[i]
        
        # 处理上一次的place最终一次
        try:
            # 处理上一次的place:AmS最终一次
            last_placed_index = range(break_point[last_placed_animation_section],break_point[i])
            this_duration = len(last_placed_index)
            this_am,am_method,am_dur,am_center = this_placed_animation
            # 如果place的this_duration小于切换时间，则清除动态切换效果
            if (this_duration<(2*am_dur+1)) & (this_am != 'NA'):
                print(WarningPrint('PAmMetDrop'))
                am_dur = 0
                am_method = 'replace'
            render_timeline.loc[last_placed_index,'AmS'] = this_am
            # this_am 可能为空的，需要先处理这种情况！
            if (this_am!=this_am) | (this_am=='NA'):
                render_timeline.loc[last_placed_index,'AmS_t'] = 0
                render_timeline.loc[last_placed_index,'AmS_a'] = 0
                render_timeline.loc[last_placed_index,'AmS_c'] = 'NA'
                render_timeline.loc[last_placed_index,'AmS_p'] = 'NA'
            else:
                alpha_timeline_A,pos_timeline_A = ambb_methods(am_method,am_dur,this_duration,i)
                render_timeline.loc[last_placed_index,'AmS_a'] = alpha_timeline_A*100
                render_timeline.loc[last_placed_index,'AmS_p'] = pos_timeline_A
                render_timeline.loc[last_placed_index,'AmS_t'] = eval('{am}.get_tick({dur})'.format(am=this_am,dur=this_duration))
                render_timeline.loc[last_placed_index,'AmS_c'] = am_center

            # 处理上一次的place:BbS最终一次
            last_placed_index = range(break_point[last_placed_bubble_section],break_point[i])
            this_duration = len(last_placed_index)
            # bb,method,method_dur,HT,MT,text_method,tx_dur,center
            this_bb,bb_method,bb_dur,this_hd,this_tx,text_method,text_dur,bb_center = this_placed_bubble
            # 如果place的this_duration小于切换时间，则清除动态切换效果
            if (this_duration<(2*bb_dur+1)) & (this_bb != 'NA'):
                print(WarningPrint('PBbMetDrop'))
                bb_dur = 0
                bb_method = 'replace'
            # 'BbS','BbS_main','BbS_header','BbS_a','BbS_c','BbS_p',
            render_timeline.loc[last_placed_index,'BbS'] = this_bb
            # this_bb 可能为空的，需要先处理这种情况！
            if (this_bb!=this_bb) | (this_bb=='NA'):
                render_timeline.loc[last_placed_index,'BbS_main'] = ''
                render_timeline.loc[last_placed_index,'BbS_header'] = ''
                render_timeline.loc[last_placed_index,'BbS_a'] = 0
                render_timeline.loc[last_placed_index,'BbS_c'] = 'NA'
                render_timeline.loc[last_placed_index,'BbS_p'] = 'NA'
            else:
                # 
                alpha_timeline_B,pos_timeline_B = ambb_methods(bb_method,bb_dur,this_duration,i)
                render_timeline.loc[last_placed_index,'BbS_a'] = alpha_timeline_B*100
                render_timeline.loc[last_placed_index,'BbS_c'] = bb_center
                render_timeline.loc[last_placed_index,'BbS_p'] = pos_timeline_B
                render_timeline.loc[last_placed_index,'BbS_main'] = this_tx
                render_timeline.loc[last_placed_index,'BbS_header'] = this_hd
                # 文字显示的参数
                if text_method == 'all':
                    if text_dur == 0:
                        pass
                    else:
                        # 将前n帧的文本设置为空白
                        render_timeline.loc[last_placed_index[0]:(last_placed_index[0]+text_dur),'BbS_main'] = ''
                elif text_method == 'w2w':
                    word_count_timeline = np.arange(0,this_duration,1)//text_dur+1
                    render_timeline.loc[last_placed_index,'BbS_main'] = UF_cut_str(render_timeline.loc[last_placed_index,'BbS_main'],word_count_timeline)
                elif text_method == 'l2l': 
                    if ((this_tx[0]=='^')|('#' in this_tx)): #如果是手动换行的列
                        word_count_timeline = get_l2l(this_tx,text_dur,this_duration) # 不保证稳定呢！
                    else:
                        line_limit = eval(this_bb+'.MainText.line_limit') #获取主文本对象的line_limit参数
                        word_count_timeline = (np.arange(0,this_duration,1)//(text_dur*line_limit)+1)*line_limit
                    render_timeline.loc[last_placed_index,'BbS_main'] = UF_cut_str(render_timeline.loc[last_placed_index,'BbS_main'],word_count_timeline)
                else:
                    pass
        except Exception as E:
            raise ParserError('ParErrCompl')

        # 去掉和前一帧相同的帧，节约了性能
        render_timeline = render_timeline.fillna('NA') #假设一共10帧
        timeline_diff = render_timeline.iloc[:-1].copy() #取第0-9帧
        timeline_diff.index = timeline_diff.index+1 #设置为第1-10帧
        timeline_diff.loc[0]='NA' #再把第0帧设置为NA
        dropframe = (render_timeline == timeline_diff.sort_index()).all(axis=1) # 这样，就是原来的第10帧和第9帧在比较了

        # 导出
        bulitin_media = pd.Series(bulitin_media,dtype=str)
        break_point = break_point.astype(int) # breakpoint 数据类型改为整数
        return render_timeline[dropframe == False].copy(),break_point,bulitin_media

    # 渲染函数
    def render(this_frame):
        global media_list
        for layer in zorder:
            # 不渲染的条件：图层为"Na"，或者np.nan
            if (this_frame[layer]=='NA')|(this_frame[layer]!=this_frame[layer]):
                continue
            elif this_frame[layer+'_a']<=0: #或者图层的透明度小于等于0(由于fillna("NA"),出现的异常)
                continue
            elif this_frame[layer] not in media_list:
                raise RenderError('UndefMedia',this_frame[layer])
            elif layer[0:2] == 'BG':
                try:
                    exec('{0}.display(surface=screen,alpha={1},adjust={2},center={3})'.format(this_frame[layer],
                                                                                            this_frame[layer+'_a'],
                                                                                            '\"'+this_frame[layer+'_p']+'\"',
                                                                                            '\"'+this_frame[layer+'_c']+'\"'))
                except Exception:
                    raise RenderError('FailRender',this_frame[layer],'Background')
            elif layer[0:2] == 'Am': # 兼容H_LG1(1)这种动画形式 alpha1.6.3
                try:
                    exec('{0}.display(surface=screen,alpha={1},adjust={2},frame={3},center={4})'.format(
                                                                                            this_frame[layer],
                                                                                            this_frame[layer+'_a'],
                                                                                            '\"'+this_frame[layer+'_p']+'\"',
                                                                                            this_frame[layer+'_t'],
                                                                                            '\"'+this_frame[layer+'_c']+'\"'))
                except Exception:
                    raise RenderError('FailRender',this_frame[layer],'Animation')
            elif layer[0:2] == 'Bb':
                try:
                    exec('{0}.display(surface=screen,text={2},header={3},alpha={1},adjust={4},center={5})'.format(this_frame[layer],
                                                                                                    this_frame[layer+'_a'],
                                                                                                    '\"'+this_frame[layer+'_main']+'\"',
                                                                                                    '\"'+this_frame[layer+'_header']+'\"',
                                                                                                    '\"'+this_frame[layer+'_p']+'\"',
                                                                                                    '\"'+this_frame[layer+'_c']+'\"'))
                except Exception:
                    raise RenderError('FailRender',this_frame[layer],'Bubble')
        for key in ['BGM','Voice','SE']:
            if (this_frame[key]=='NA')|(this_frame[key]!=this_frame[key]): #如果是空的
                continue
            elif this_frame[key] == 'stop': # a 1.6.0更新
                pygame.mixer.music.stop() #停止
                pygame.mixer.music.unload() #换碟
            elif (this_frame[key] not in media_list): #不是预先定义的媒体，则一定是合法的路径
                if key == 'BGM':
                    temp_BGM = BGM(filepath=this_frame[key][1:-1])
                    temp_BGM.display()
                else:
                    temp_Audio = Audio(filepath=this_frame[key][1:-1])
                    temp_Audio.display(channel=eval(channel_list[key]))#这里的参数需要是对象
            else: # 预先定义的媒体
                try:
                    if key == 'BGM':
                        exec('{0}.display()'.format(this_frame[key])) #否则就直接播放对象
                    else:
                        exec('{0}.display(channel={1})'.format(this_frame[key],channel_list[key])) #否则就直接播放对象
                except Exception:
                    raise ParserError('FailPlay',this_frame[key])
        return 1
    # 手动换行的l2l
    def get_l2l(ts,text_dur,this_duration): #如果是手动换行的列
        lines = ts.split('#')
        wc_list = []
        len_this = 0
        for x,l in enumerate(lines): #x是井号的数量
            len_this = len_this +len(l)+1 #当前行的长度
            #print(len_this,len(l),x,ts[0:len_this])
            wc_list.append(np.ones(text_dur*len(l))*len_this)
        try:
            wc_list.append(np.ones(this_duration - (len(ts)-x)*text_dur)*len(ts)) #this_duration > est # 1.6.1 update
            word_count_timeline = np.hstack(wc_list)
        except Exception: 
            word_count_timeline = np.hstack(wc_list) # this_duration < est
            word_count_timeline = word_count_timeline[0:this_duration]
        return word_count_timeline.astype(int)

    # 倒计时器
    def timer(clock):
        white.display(screen)
        screen.blit(note_text.render('%d'%clock,fgcolor=(150,150,150,255),size=0.0926*Height)[0],(0.484*Width,0.463*Height)) # for 1080p
        pygame.display.update()
        pygame.time.delay(1000)

    def stop_SE():
        for Ch in channel_list.values():
            exec(Ch+'.stop()')

    def pause_SE(stats):
        if stats == 0:
            pygame.mixer.music.pause()
            for Ch in channel_list.values():
                exec(Ch+'.pause()')
        else:
            pygame.mixer.music.unpause()
            for Ch in channel_list.values():
                exec(Ch+'.unpause()')

    # Main():

    print(MainPrint('Welcome',EDITION))

    # 检查是否需要先做语音合成

    if args.SynthesisAnyway == True:
        command = 'RplGenCore.exe --Modules speech_synthesizer --LogFile {lg} --MediaObjDefine {md} --CharacterTable {ct} --OutputPath {of} --AccessKey {AK} --AccessKeySecret {AS} --Appkey {AP} '
        command = command + '--Azurekey {AZ} --ServRegion {SR} --Language {la}'
        command = command.format(lg = args.LogFile.replace('\\','/'),md = args.MediaObjDefine.replace('\\','/'), of = args.OutputPath, ct = args.CharacterTable.replace('\\','/'),
                                AK = args.AccessKey,AS = args.AccessKeySecret,AP = args.Appkey,AZ = args.Azurekey, SR =args.ServRegion, la = args.Language)
        print(MainPrint('SythAnyway'))
        print(CMDPrint('Command',command))
        try:
            exit_status = os.system(command)
            print(CMDPrint('BreakLine'))
            # 0. 有覆盖原log，合成正常，可以继续执行主程序
            if exit_status == 0:
                pass
            # 1. 无覆盖原log，无需合成，可以继续执行主程序
            elif exit_status == 1:
                print(WarningPrint('NoValidSyth'))
            # 2. 无覆盖原log，合成未完成，不能继续执行主程序
            elif exit_status == 2:
                raise SynthesisError('CantBegin')
            # 3. 有覆盖原log，合成未完成，不能继续执行主程序
            elif exit_status == 3:
                raise SynthesisError('SynBreak')
            else:
                raise SynthesisError('Unknown')
        except Exception as E:
            print(E)
            system_terminated('Error')

    # 载入媒体文件
    print(MainPrint('LoadMedef'))

    try:
        object_define_text = open(args.MediaObjDefine,'r',encoding='utf-8').read()#.split('\n') # 修改后的逻辑
    except UnicodeDecodeError as E:
        print(DecodeError('DecodeErr',E))
        system_terminated('Error')
    if object_define_text[0] == '\ufeff': # UTF-8 BOM
        print(WarningPrint('UFT8BOM'))
        object_define_text = object_define_text[1:] # 去掉首位
    object_define_text = object_define_text.split('\n')

    media_list=[]
    for i,text in enumerate(object_define_text):
        if text == '':
            continue
        elif text[0] == '#':
            continue
        else:
            try:
                exec(text) #对象实例化
                obj_name = text.split('=')[0]
                obj_name = obj_name.replace(' ','')
                if obj_name in occupied_variable_name:
                    raise SyntaxsError('OccName')
                elif (len(re.findall('\w+',obj_name))==0)|(obj_name[0].isdigit()):
                    raise SyntaxsError('InvaName')
                media_list.append(obj_name) #记录新增对象名称
            except Exception as E:
                print(E)
                print(SyntaxsError('MediaDef',text,str(i+1)))
                system_terminated('Error')
    black = Background('black')
    white = Background('white')
    media_list.append('black')
    media_list.append('white')

    # 载入角色配置文件
    print(MainPrint('LoadChrtab'))

    try:
        if args.CharacterTable.split('.')[-1] in ['xlsx','xls']:
            import warnings
            with warnings.catch_warnings():
                warnings.simplefilter('ignore') # 禁用读取excel时报出的：UserWarning: Data Validation extension is not supported and will be removed
                charactor_table = pd.read_excel(args.CharacterTable,dtype = str,sheet_name='角色配置').fillna('NA') # 支持excel格式的角色配置表
        else:
            charactor_table = pd.read_csv(args.CharacterTable,sep='\t',dtype = str).fillna('NA')
        charactor_table.index = charactor_table['Name']+'.'+charactor_table['Subtype']
        if ('Animation' not in charactor_table.columns) | ('Bubble' not in charactor_table.columns): # 139debug
            raise SyntaxsError('MissCol')
    except SyntaxsError as E:
        print(E)
        system_terminated('Error')
    except Exception as E:
        print(SyntaxsError('CharTab',E))
        system_terminated('Error')

    # 载入log文件 parser()
    print(MainPrint('LoadRGL'))

    try:
        stdin_text = open(args.LogFile,'r',encoding='utf8').read()#.split('\n')
    except UnicodeDecodeError as E:
        print(DecodeError('DecodeErr',E))
        system_terminated('Error')
    if stdin_text[0] == '\ufeff': # 139 debug # 除非是完全空白的文件
        print(WarningPrint('UFT8BOM'))
        stdin_text = stdin_text[1:]
    stdin_text = stdin_text.split('\n')
    try:
        render_timeline,break_point,bulitin_media = parser(stdin_text)
    except ParserError as E:
        print(E)
        system_terminated('Error')

    # 判断是否指定输出路径，准备各种输出选项
    if args.OutputPath != None:
        print(MainPrint('OutTime',args.OutputPath))
        # 如果有输出路径，导出时间轴文件
        timenow = '%d'%time.time()
        timeline_ofile = open(args.OutputPath+'/'+timenow+'.timeline','wb')
        pickle.dump([render_timeline,break_point,bulitin_media],timeline_ofile)
        timeline_ofile.close()
        # 如果导出PR项目
        if args.ExportXML == True:
            command = 'RplGenCore.exe --Modules export_xml --TimeLine {tm} --MediaObjDefine {md} --OutputPath {of} --FramePerSecond {fps} --Width {wd} --Height {he} --Zorder {zd} --Language {la}'
            command = command.format(tm = args.OutputPath+'/'+timenow+'.timeline',
                                    md = args.MediaObjDefine.replace('\\','/'), of = args.OutputPath.replace('\\','/'), 
                                    fps = frame_rate, wd = Width, he = Height, zd = args.Zorder, la=args.Language)
            print(MainPrint('ExportXML'))
            print(CMDPrint('Command',command))
            try:
                exit_status = os.system(command)
                print(CMDPrint('BreakLine'))
                if exit_status != 0:
                    raise OSError('Major error occurred in export_xml!')
            except Exception as E:
                print(WarningPrint('XMLFail',E))
        # 如果导出视频文件
        if args.ExportVideo == True:
            command = 'RplGenCore.exe --Modules export_video --TimeLine {tm} --MediaObjDefine {md} --OutputPath {of} --FramePerSecond {fps} --Width {wd} --Height {he} --Zorder {zd} --Quality {ql} --Language {la}'
            command = command.format(tm = args.OutputPath+'/'+timenow+'.timeline',
                                    md = args.MediaObjDefine.replace('\\','/'), of = args.OutputPath.replace('\\','/'), 
                                    fps = frame_rate, wd = Width, he = Height, zd = args.Zorder,ql = args.Quality, la=args.Language)
            print(MainPrint('ExportMp4'))
            print(CMDPrint('Command',command))
            try:
                exit_status = os.system(command)
                print(CMDPrint('BreakLine'))
                if exit_status != 0:
                    raise OSError('Major error occurred in export_video!')
            except Exception as E:
                print(WarningPrint('Mp4Fail',E))
            # 如果导出为视频，则提前终止程序
            system_terminated('Video')

    # 初始化界面
    if args.FixScreenZoom == True:
        try:
            import ctypes
            ctypes.windll.user32.SetProcessDPIAware() #修复错误的缩放，尤其是在移动设备。
        except Exception:
            print(WarningPrint('FixScrZoom'))

    pygame.init()
    pygame.display.set_caption('TRPG Replay Generator '+EDITION)
    fps_clock=pygame.time.Clock()
    screen = pygame.display.set_mode((Width,Height))
    pygame.display.set_icon(pygame.image.load('./media/icon.png'))
    note_text = pygame.freetype.Font('./media/SourceHanSansCN-Regular.otf')

    # 建立音频轨道
    VOICE = pygame.mixer.Channel(1)
    SOUEFF = pygame.mixer.Channel(2)
    channel_list = {'Voice':'VOICE','SE':'SOUEFF'}

    # 转换媒体对象
    for media in media_list: 
        try:
            exec(media+'.convert()')
        except Exception as E:
            print(MediaError('ErrCovert',media,E))
            system_terminated('Error')

    # 预备画面
    white.display(screen)
    screen.blit(pygame.transform.scale(pygame.image.load('./media/icon.png'),(Height//5,Height//5)),(0.01*Height,0.79*Height))
    screen.blit(note_text.render('Welcome to TRPG Replay Generator!',fgcolor=(150,150,150,255),size=0.0315*Width)[0],(0.230*Width,0.460*Height)) # for 1080p
    screen.blit(note_text.render(EDITION,fgcolor=(150,150,150,255),size=0.0278*Height)[0],(0.900*Width,0.963*Height))
    screen.blit(note_text.render('Press space to begin.',fgcolor=(150,150,150,255),size=0.0278*Height)[0],(0.417*Width,0.926*Height))
    pygame.display.update()
    begin = False
    while begin == False:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                system_terminated('User')
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    pygame.time.delay(1000)
                    pygame.quit()
                    system_terminated('User')
                elif event.key == pygame.K_SPACE:
                    begin = True
                    break
    for s in np.arange(5,0,-1):
        timer(s)

    # 主循环
    n=0
    forward = 1 #forward==0代表暂停
    show_detail_info = 0 # show_detail_info == 1代表显示详细信息
    detail_info = {0:"Project: Resolution: {0}x{1} ; FrameRate: {2} fps;".format(Width,Height,frame_rate),
                1:"Render Speed: {0} fps",
                2:"Frame: {0}/"+str(break_point.max())+" ; Section: {1}/"+str(len(break_point)),
                3:"Command: {0}",
                4:"Zorder: {0}".format('>>>'+'>'.join(zorder)+'>>>'),
                5:"Layer: BG1:{0}; BG2:{1};",
                6:"Layer: Am1:{0}; Am2:{1}; Am3:{2}; AmS:{3}",
                7:"Layer: Bb:{0}; HD:{1}; TX:{2}",
                8:"Layer: BbS:{0}; HDS:{1}; TXS:{2}"
                }
    resize_screen = 0 # 是否要强制缩小整个演示窗体
    while n < break_point.max():
        ct = time.time()
        try:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    system_terminated('User')
                elif event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_ESCAPE:
                        stop_SE()
                        pygame.time.delay(1000)
                        pygame.quit()
                        system_terminated('User')
                    elif event.key in [pygame.K_a,pygame.K_LEFT]:
                        n=break_point[(break_point-n)<0].max()
                        n=break_point[(break_point-n)<0].max()
                        if n != n: # 确保不会被a搞崩
                            n = 0
                        stop_SE()
                        continue
                    elif event.key in [pygame.K_d,pygame.K_RIGHT]:
                        n=break_point[(break_point-n)>0].min()
                        stop_SE()
                        continue
                    elif event.key in [pygame.K_F11, pygame.K_p]: # 调整缩放一半
                        from pygame._sdl2.video import Window
                        window = Window.from_display_module()
                        resize_screen = 1 - resize_screen
                        if resize_screen == 1:
                            screen_resized = pygame.display.set_mode((Width//2,Height//2))
                            screen = pygame.Surface((Width,Height),pygame.SRCALPHA)
                            window.position = (100,100)
                        else:
                            screen = pygame.display.set_mode((Width,Height))
                            window.position = (0,0)
                        pygame.display.update()
                    elif event.key in [pygame.K_F5, pygame.K_i]: # 详细信息
                        show_detail_info = 1 - show_detail_info # 1->0 0->1
                    elif event.key == pygame.K_SPACE: #暂停
                        forward = 1 - forward # 1->0 0->1
                        pause_SE(forward) # 0:pause,1:unpause
                    else:
                        pass
            if n in render_timeline.index:
                this_frame = render_timeline.loc[n]
                render(this_frame)
                # 如果正在暂停
                if forward == 0:
                    screen.blit(note_text.render('Press space to continue.',fgcolor=cmap['notetext'],size=0.0278*Height)[0],(0.410*Width,0.926*Height)) # pause
                # 显示详情模式
                if show_detail_info == 1:
                    screen.blit(note_text.render(detail_info[0],fgcolor=cmap['notetext'],size=0.0185*Height)[0],(10,10))
                    screen.blit(note_text.render(detail_info[2].format(n,this_frame['section']+1),fgcolor=cmap['notetext'],size=0.0185*Height)[0],(10,10+0.0666*Height))
                    screen.blit(note_text.render(detail_info[3].format(stdin_text[this_frame['section']]),fgcolor=cmap['notetext'],size=0.0185*Height)[0],(10,10+0.1*Height))
                    screen.blit(note_text.render(detail_info[4],fgcolor=cmap['notetext'],size=0.0185*Height)[0],(10,10+0.1333*Height))
                    screen.blit(note_text.render(detail_info[5].format(this_frame['BG1'],this_frame['BG2']),fgcolor=cmap['notetext'],size=0.0185*Height)[0],(10,10+0.1666*Height))
                    screen.blit(note_text.render(detail_info[6].format(this_frame['Am1'],this_frame['Am2'],this_frame['Am3'],this_frame['AmS']),fgcolor=cmap['notetext'],size=0.0185*Height)[0],(10,10+0.2*Height))
                    screen.blit(note_text.render(detail_info[7].format(this_frame['Bb'],this_frame['Bb_header'],this_frame['Bb_main']),fgcolor=cmap['notetext'],size=0.0185*Height)[0],(10,10+0.2333*Height))
                    screen.blit(note_text.render(detail_info[8].format(this_frame['BbS'],this_frame['BbS_header'],this_frame['BbS_main']),fgcolor=cmap['notetext'],size=0.0185*Height)[0],(10,10+0.2666*Height))
                    screen.blit(note_text.render(detail_info[1].format(int(1/(time.time()-ct+1e-4))),fgcolor=cmap['notetext'],size=0.0185*Height)[0],(10,10+0.0333*Height))
                # 仅显示帧率
                else:
                    screen.blit(note_text.render('%d'%(1//(time.time()-ct+1e-4)),fgcolor=cmap['notetext'],size=0.0278*Height)[0],(10,10)) ##render rate +1e-4 to avoid float divmod()
                # 如果缩放到一半大小
                if resize_screen == 1:
                    screen_resized.blit(pygame.transform.scale(screen,(Width//2,Height//2)),(0,0))
            else:
                pass # 节约算力
            pygame.display.update()
            n = n + forward #下一帧
            fps_clock.tick(frame_rate)
        except RenderError as E:
            print(E)
            print(RenderError('BreakFrame',n))
            pygame.quit()
            system_terminated('Error')
    pygame.quit()
    system_terminated('End')

elif args.Modules == 'speech_synthesizer':
    from core.Exceptions import RplGenError, Print
    from core.Exceptions import DecodeError, IgnoreInput, MediaError, ArgumentError, ParserError, SyntaxsError, SynthesisError
    from core.Exceptions import SynthPrint, WarningPrint

    # 初始化日志打印
    if args.Language == 'zh':
        # 中文
        Print.lang = 1 
        RplGenError.lang = 1
    else:
        # 英文
        Print.lang == 0
        RplGenError.lang = 0

    try:
        if args.PreviewOnly == 1:
            # 如果选择仅预览，则忽略输入文件！
            if args.Init in ['Aliyun','Azure']:
                raise IgnoreInput()
            else:
                raise ArgumentError('BadInit',args.Init)
        for path in [args.LogFile,args.CharacterTable,args.MediaObjDefine]:
            if path is None:
                raise ArgumentError('MissInput')
            if os.path.isfile(path) == False:
                raise ArgumentError('FileNotFound',path)

        if args.OutputPath is None:
            raise ArgumentError('MustOutput')
        elif os.path.isdir(args.OutputPath) == False:
            try:
                os.makedirs(args.OutputPath)
            except Exception:
                raise ArgumentError('MkdirErr',args.OutputPath)
        else:
            pass
        args.OutputPath = args.OutputPath.replace('\\','/')
    except IgnoreInput as E:
        print(E)
    except Exception as E:
        print(E)
        sys.exit(2) # 缺少必要文件路径，异常退出

    # 包导入

    import pandas as pd
    import numpy as np
    from pygame import mixer
    import re
    from shutil import copy
    import tkinter as tk
    from tkinter import ttk
    from tkinter import messagebox
    from tkinter import filedialog

    # 语音合成服务
    from core.TTSengines import Aliyun_TTS_engine,Azure_TTS_engine,voice_lib

    Aliyun_TTS_engine.AKID = args.AccessKey
    Aliyun_TTS_engine.AKKEY = args.AccessKeySecret
    Aliyun_TTS_engine.APPKEY = args.Appkey
    Azure_TTS_engine.AZUKEY = args.Azurekey
    Azure_TTS_engine.service_region = args.ServRegion

    # 从主程序借来的Audio类
    from core.Medias import Audio
    # 正则表达式定义
    from core.Regexs import RE_dialogue,RE_characor,RE_asterisk
    # 函数定义
    from core.Utils import clean_ts,isnumber,mod62_timestamp

    # 全局变量
    media_list=[]
    occupied_variable_name = open('./media/occupied_variable_name.list','r',encoding='utf8').read().split('\n')

    # 解析对话行 []
    def get_dialogue_arg(text):
        cr,cre,ts,tse,se = RE_dialogue.findall(text)[0]
        this_charactor = RE_characor.findall(cr)
        # 语音和音效参数
        if se == '':
            asterisk_label = []
        else:
            asterisk_label = RE_asterisk.findall(se)

        return (this_charactor,ts,asterisk_label)

    # 解析函数
    def parser(stdin_text):
        # parsed log 列名
        asterisk_line_columns=['asterisk_label','character','speech_text','category','filepath']
        asterisk_line = pd.DataFrame(index=range(0,len(stdin_text)),columns=asterisk_line_columns)
        for i,text in enumerate(stdin_text):
            # 空白行
            if text == '':
                continue
            # 注释行 格式： # word
            elif text[0] == '#':
                continue
            # 对话行 格式： [角色1,角色2(30).happy]<replace=30>:巴拉#巴拉#巴拉<w2w=1>{*}
            elif text[0] == '[':
                try:
                    # 读取角色、文本、音频信息
                    this_charactor,ts,asterisk_label = get_dialogue_arg(text)
                    if len(asterisk_label) == 0:
                        continue
                    elif len(asterisk_label) == 1:
                        K0,K1,K2 = asterisk_label[0]
                        asterisk_line.loc[i,'asterisk_label'] = K0
                        #1.{*}
                        if K0 == '{*}':
                            asterisk_line.loc[i,'category'] = 1
                            asterisk_line.loc[i,'speech_text'] = clean_ts(ts) #need clean!
                            asterisk_line.loc[i,'filepath'] = 'None'
                        #2.{*生成这里面的文本，我在添加一点标点符号}
                        elif (K1=='')&(K2!=''):
                            asterisk_line.loc[i,'category'] = 2
                            asterisk_line.loc[i,'speech_text'] = K2
                            asterisk_line.loc[i,'filepath'] = 'None'
                        #3.{"./timeline.mp3",*}
                        elif (os.path.isfile(K1[1:-2])==True)&(K2==''):
                            asterisk_line.loc[i,'category'] = 3
                            asterisk_line.loc[i,'speech_text'] = 'None'
                            asterisk_line.loc[i,'filepath'] = K1[1:-2]
                        #4.{"./timeline.mp3",*30}|{NA,*30}
                        elif ((os.path.isfile(K1[1:-2])==True)|(K1[:-1]=='NA'))&(isnumber(K2)==True): # a 1.9.6
                            asterisk_line.loc[i,'category'] = 4
                            asterisk_line.loc[i,'speech_text'] = 'None'
                            asterisk_line.loc[i,'filepath'] = K1[1:-2]
                        #4.{SE1,*} 始终无视这种标记
                        elif K1[0:-1] in media_list:
                            asterisk_line.loc[i,'category'] = 4
                            asterisk_line.loc[i,'speech_text'] = 'None'
                            asterisk_line.loc[i,'filepath'] = K1[0:-1]
                            print(WarningPrint('DefAsterSE',K1[0:-1]))
                        elif (os.path.isfile(K1[1:-2])==False): #3&4.指定了不存在的文件路径
                            raise ParserError('BadAsterSE',K1[0:-1])
                        else: # 其他的不合规的星标文本
                            raise ParserError('InvAster')
                        
                    else:
                        raise ParserError('2muchAster',str(i+1))
                    name,alpha,subtype= this_charactor[0]
                    if subtype == '':
                        subtype = '.default'
                    asterisk_line.loc[i,'character'] = name+subtype
                except Exception as E:
                    print(E)
                    raise ParserError('ParErrDial', str(i+1))
            else:
                pass
        return asterisk_line.dropna()

    # 音频合成函数
    def synthesizer(key,asterisk):
        #读取Voice信息
        if asterisk['category'] > 2: #如果解析结果为3&4，不执行语音合成
            return 'Keep',False
        elif asterisk['character'] not in charactor_table.index: #指定了未定义的发言角色
            print(WarningPrint('UndefChar',asterisk['character']))
            return 'None',False
        else:
            charactor_info = charactor_table.loc[asterisk['character']]
        #如果这个角色本身就不带有发言
        if charactor_info['TTS'] == 'None':
            print(WarningPrint('CharNoVoice',asterisk['character']))
            return 'None',False
        else:
            # alpha 1.12.4 在输出路径里加上timestamp，和序号和行号统一
            ofile = args.OutputPath+'/'+'auto_AU_%d'%(key+1)+'_'+mod62_timestamp()+'.wav'
            # alpha 1.12.4 如果合成出现异常，重试
            for time_retry in range(1,6):
                # 最多重试5次
                try:
                    charactor_info['TTS'].start(asterisk['speech_text'],ofile) #执行合成
                    return ofile,True  # 如果能不出异常的结束，则退出循环
                except Exception as E:
                    # 如果出现了异常
                    print(WarningPrint('SynthFail', str(key+1), str(time_retry), E))
            # 如果超出了5次尝试，返回Fatal
            return 'Fatal',False

    # 预览窗体
    def open_Tuning_windows(init_type='Aliyun'):
        # 根据选中的语音服务，切换frame
        def show_selected_options(event):
            nonlocal servframe_display
            servframe_display.place_forget()
            try:
                select = Servicetype[tts_service.get()]
            except:
                messagebox.showerror(title='错误',message='服务名错误！')
                select = Servicetype['阿里云']
            select.place(x=10,y=40,width=360,height=190)
            servframe_display = select
        # 根据选中的Azure音源，更新描述
        def update_selected_voice_aliyun(event):
            aliyun_voice_selected  = aliyun_voice.get()
            aliyun_voice_description.config(text='('+voice_lib.loc[aliyun_voice_selected,'description']+')')
        # 根据选中的Azure音源，更新可用的role和style
        def update_selected_voice_azure(event):
            azure_voice_selected = azure_voice.get()
            azure_style_available = voice_lib.loc[azure_voice_selected,'style'].split(',')
            azure_role_available = voice_lib.loc[azure_voice_selected,'role'].split(',')
            azure_voice_description.config(text='('+voice_lib.loc[azure_voice_selected,'description']+')')
            azure_style_combobox.config(values=azure_style_available)
            azure_role_combobox.config(values=azure_role_available)
            azure_style.set('general')
            azure_role.set('Default')
            azure_degree.set(1.0)
        # 将选择条的数值强行转换为整型
        def get_scale_to_intvar(variable):
            variable.set(int(variable.get()))
        # 复制到剪贴板
        def copy_args_clipboard():
            if tts_service.get() == '阿里云':
                voice_this = aliyun_voice.get()
            elif tts_service.get() == '微软Azure':
                voice_this = 'Azure::'+azure_voice.get()+':'+azure_style.get()+':'+str(azure_degree.get())+':'+azure_role.get()
            copy_to_clipboard = '\t'.join([voice_this,str(speech_rate.get()),str(pitch_rate.get())])
            Tuning_windows.clipboard_clear()
            Tuning_windows.clipboard_append(copy_to_clipboard)
            #messagebox.showinfo(title='复制到剪贴板',message='已成功将\n'+copy_to_clipboard+'\n复制到剪贴板')
        # 执行合成
        def exec_synthesis(command='play'):
            # 音源不同，语音合成的服务不同
            if tts_service.get() == '阿里云':
                voice_this = aliyun_voice.get()
                TTS_engine = Aliyun_TTS_engine
            elif tts_service.get() == '微软Azure':
                voice_this = azure_voice.get()+':'+azure_style.get()+':'+str(azure_degree.get())+':'+azure_role.get()
                TTS_engine = Azure_TTS_engine
            # 如果没有指定voice
            if voice_this.split(':')[0]=='':
                messagebox.showerror(title='错误',message='缺少音源名!')
                return 0
            try:
                this_tts_engine = TTS_engine(name='preview',
                                            voice = voice_this,
                                            speech_rate=speech_rate.get(),
                                            pitch_rate=pitch_rate.get(),
                                            aformat='wav')
            except KeyError as E: # 非法的音源名
                print(WarningPrint('BadSpeaker',E))
                messagebox.showerror(title='合成失败',message="[错误]：不支持的音源名！")
                return 0
            # 执行合成
            try:
                this_tts_engine.start(text_to_synth.get("0.0","end"),'./media/preview_tempfile.wav')
            except Exception as E:
                print(WarningPrint('PrevFail',E))
                messagebox.showerror(title='合成失败',message="[错误]：语音合成失败！")
                return 0
            if command == 'play':
                # 播放合成结果
                try:
                    Audio('./media/preview_tempfile.wav').display(preview_channel)
                    return 1
                except Exception as E:
                    print(WarningPrint('AuPlayFail',E))
                    messagebox.showerror(title='播放失败',message="[错误]：无法播放语音！")
                    return 0
            elif command == 'save':
                try:
                    default_filename = voice_this.split(':')[0] + '_' + mod62_timestamp()+ '.wav'
                    save_filepath = filedialog.asksaveasfilename(initialfile=default_filename,filetypes=[('音频文件','*.wav')])
                    if save_filepath != '':
                        copy('./media/preview_tempfile.wav',save_filepath)
                except Exception as E:
                    print(WarningPrint('SaveFail',E))
                    messagebox.showerror(title='保存失败',message="[错误]：无法保存文件！")
                    return 0

        # 窗口
        Tuning_windows = tk.Tk()
        Tuning_windows.resizable(0,0)
        Tuning_windows.geometry("400x460")
        Tuning_windows.config(background ='#e0e0e0')
        Tuning_windows.title('语音合成试听')
        try:
            Tuning_windows.iconbitmap('./media/icon.ico')
        except tk.TclError:
            pass
        #Tuning_windows.transient(father)
        # 声音轨道
        preview_channel = mixer.Channel(1)
        # 主框
        tune_main_frame = tk.Frame(Tuning_windows)
        tune_main_frame.place(x=10,y=10,height=440,width=380)
        # 语音服务变量
        tts_service = tk.StringVar(tune_main_frame)
        tts_service.set({'Aliyun':'阿里云','Azure':'微软Azure'}[init_type])
        # 语速语调文本变量
        pitch_rate = tk.IntVar(tune_main_frame)
        pitch_rate.set(0)
        speech_rate = tk.IntVar(tune_main_frame)
        speech_rate.set(0)
        # 版本号
        tk.Label(tune_main_frame,text='Speech_synthesizer '+EDITION,fg='#d0d0d0').place(x=170,y=5,height=15)
        tk.Label(tune_main_frame,text='For TRPG-replay-generator.',fg='#d0d0d0').place(x=170,y=20,height=15)
        # 选中音源变量
        tk.Label(tune_main_frame,text='服务：').place(x=10,y=10,width=40,height=25)
        choose_type = ttk.Combobox(tune_main_frame,textvariable=tts_service,value=['阿里云','微软Azure'])
        choose_type.place(x=50,y=10,width=100,height=25)
        choose_type.bind("<<ComboboxSelected>>",show_selected_options)
        # 音源窗口
        Aliyun_frame = tk.LabelFrame(tune_main_frame,text='阿里-参数')
        Azure_frame = tk.LabelFrame(tune_main_frame,text='微软-参数')
        text_frame = tk.LabelFrame(tune_main_frame,text='文本')
        Servicetype = {'阿里云':Aliyun_frame,'微软Azure':Azure_frame}
        # 初始化显示的服务
        servframe_display = Servicetype[tts_service.get()]
        servframe_display.place(x=10,y=40,width=360,height=190)
        text_frame.place(x=10,y=240,width=360,height=150)
        # 复制到剪贴板按钮
        ttk.Button(Aliyun_frame,text='复制',command=copy_args_clipboard).place(x=310,y=-5,width=40,height=25)
        ttk.Button(Azure_frame,text='复制',command=copy_args_clipboard).place(x=310,y=-5,width=40,height=25)
        # 阿里云参数
        aliyun_voice = tk.StringVar(Aliyun_frame)
        ttk.Label(Aliyun_frame,text='音源名:').place(x=10,y=10,width=65,height=25)
        ttk.Label(Aliyun_frame,text='语速:').place(x=10,y=40,width=65,height=25)
        ttk.Label(Aliyun_frame,text='语调:').place(x=10,y=70,width=65,height=25)
        # 选择音源
        aliyun_voice_combobox = ttk.Combobox(Aliyun_frame,textvariable=aliyun_voice,values=list(voice_lib[voice_lib.service=='Aliyun'].index))
        aliyun_voice_combobox.place(x=75,y=10,width=100,height=25)
        aliyun_voice_combobox.bind("<<ComboboxSelected>>",update_selected_voice_aliyun)
        aliyun_voice_description = ttk.Label(Aliyun_frame,text='初始化',anchor='w')
        aliyun_voice_description.place(x=180,y=10,width=130,height=25)
        # 选择音源参数
        ttk.Spinbox(Aliyun_frame,from_=-500,to=500,textvariable=speech_rate,increment=10).place(x=75,y=40,width=50,height=25)
        ttk.Spinbox(Aliyun_frame,from_=-500,to=500,textvariable=pitch_rate,increment=10).place(x=75,y=70,width=50,height=25)
        ttk.Scale(Aliyun_frame,from_=-500,to=500,variable=speech_rate,command=lambda x:get_scale_to_intvar(speech_rate)).place(x=135,y=40,width=200,height=25)
        ttk.Scale(Aliyun_frame,from_=-500,to=500,variable=pitch_rate,command=lambda x:get_scale_to_intvar(pitch_rate)).place(x=135,y=70,width=200,height=25)
        # Azure参数
        azure_voice = tk.StringVar(Azure_frame)
        azure_style = tk.StringVar(Azure_frame)
        azure_degree = tk.DoubleVar(Azure_frame)
        azure_role = tk.StringVar(Azure_frame)
        azure_style.set('general')
        azure_degree.set(1.0)
        azure_role.set('Default')
        ttk.Label(Azure_frame,text='音源名:').place(x=10,y=10,width=65,height=25)
        ttk.Label(Azure_frame,text='风格:').place(x=10,y=40,width=65,height=25)
        ttk.Label(Azure_frame,text='风格强度:').place(x=215,y=40,width=65,height=25)
        ttk.Label(Azure_frame,text='扮演:').place(x=10,y=70,width=65,height=25)
        ttk.Label(Azure_frame,text='语速:').place(x=10,y=100,width=65,height=25)
        ttk.Label(Azure_frame,text='语调:').place(x=10,y=130,width=65,height=25)
        ## 选择音源名
        azure_voice_combobox = ttk.Combobox(Azure_frame,textvariable=azure_voice,values=list(voice_lib[voice_lib.service=='Azure'].index))
        azure_voice_combobox.place(x=75,y=10,width=170,height=25)
        azure_voice_combobox.bind("<<ComboboxSelected>>",update_selected_voice_azure)
        azure_voice_description = ttk.Label(Azure_frame,text='初始化',anchor='w')
        azure_voice_description.place(x=250,y=10,width=60,height=25)
        ## 选择style就role
        azure_style_combobox = ttk.Combobox(Azure_frame,textvariable=azure_style,values=['general'])
        azure_style_combobox.place(x=75,y=40,width=130,height=25)
        ttk.Spinbox(Azure_frame,textvariable=azure_degree,from_=0.01,to=2,increment=0.1).place(x=285,y=40,width=50,height=25)
        azure_role_combobox = ttk.Combobox(Azure_frame,textvariable=azure_role,values=['Default'])
        azure_role_combobox.place(x=75,y=70,width=260,height=25)
        ## 选择语速和语调
        ttk.Spinbox(Azure_frame,from_=-500,to=500,textvariable=speech_rate,increment=10).place(x=75,y=100,width=50,height=25)
        ttk.Spinbox(Azure_frame,from_=-500,to=500,textvariable=pitch_rate,increment=10).place(x=75,y=130,width=50,height=25)
        ttk.Scale(Azure_frame,from_=-500,to=500,variable=speech_rate,command=lambda x:get_scale_to_intvar(speech_rate)).place(x=135,y=100,width=200,height=25)
        ttk.Scale(Azure_frame,from_=-500,to=500,variable=pitch_rate,command=lambda x:get_scale_to_intvar(pitch_rate)).place(x=135,y=130,width=200,height=25)
        # 文本框体
        text_to_synth = tk.Text(text_frame,font=("黑体",11))
        text_to_synth.place(x=10,y=5,width=335,height=115)
        text_to_synth.insert(tk.END,'在这里输入你想要合成的文本！')
        # 确定合成按钮
        ttk.Button(tune_main_frame,text='播放',command=lambda:exec_synthesis('play')).place(x=120,y=395,height=40,width=60)
        ttk.Button(tune_main_frame,text='保存',command=lambda:exec_synthesis('save')).place(x=200,y=395,height=40,width=60)
        # 主循环
        Tuning_windows.mainloop()

    # 语音合成
    def main():
        global charactor_table
        global media_list

        print(SynthPrint('Welcome',EDITION))
        print(SynthPrint('SaveAt',args.OutputPath))
        # 载入ct文件
        try:
            if args.CharacterTable.split('.')[-1] in ['xlsx','xls']:
                import warnings
                with warnings.catch_warnings():
                    warnings.simplefilter('ignore') # 禁用读取excel时报出的：UserWarning: Data Validation extension is not supported and will be removed
                    charactor_table = pd.read_excel(args.CharacterTable,dtype = str,sheet_name='角色配置') # 支持excel格式的角色配置表
            else:
                charactor_table = pd.read_csv(args.CharacterTable,sep='\t',dtype = str)
            charactor_table.index = charactor_table['Name']+'.'+charactor_table['Subtype']
            if 'Voice' not in charactor_table.columns:
                print(WarningPrint('MissVoice'))
        except Exception as E:
            print(SyntaxsError('CharTab',E))
            sys.exit(2) # 无法载入角色表，异常退出

        # 填补缺省值
        if 'Voice' not in charactor_table.columns:
            charactor_table['Voice'] = 'NA'
        else:
            charactor_table['Voice'] = charactor_table['Voice'].fillna('NA')
        if 'SpeechRate' not in charactor_table.columns:
            charactor_table['SpeechRate'] = 0
        else:
            charactor_table['SpeechRate'] = charactor_table['SpeechRate'].fillna(0).astype(int)
        if 'PitchRate' not in charactor_table.columns:
            charactor_table['PitchRate'] = 0
        else:
            charactor_table['PitchRate'] = charactor_table['PitchRate'].fillna(0).astype(int)
        # 填补剩余空缺值
        charactor_table = charactor_table.fillna('NA')

        # 建立TTS_engine的代码
        TTS = pd.Series(index=charactor_table.index,dtype='str')
        TTS_define_tplt = "Aliyun_TTS_engine(name='{0}',voice='{1}',speech_rate={2},pitch_rate={3})"
        AZU_define_tplt = "Azure_TTS_engine(name='{0}',voice='{1}',speech_rate={2},pitch_rate={3})"
        for key,value in charactor_table.iterrows():
            if (value.Voice != value.Voice)|(value.Voice=="NA"): # 如果音源是NA,就pass alpha1.6.3
                TTS[key] = '"None"'
            elif value.Voice in Aliyun_TTS_engine.voice_list: # 阿里云模式
                TTS[key] = TTS_define_tplt.format(key,value.Voice,value.SpeechRate,value.PitchRate)
            elif value.Voice[0:7] == 'Azure::': # Azure 模式 alpha 1.10.3
                TTS[key] = AZU_define_tplt.format(key,value.Voice[7:],value.SpeechRate,value.PitchRate)
            else:
                print(WarningPrint('BadSpeaker',value.Voice))
                TTS[key] = '"None"'
        # 应用并保存在charactor_table内
        try:
            charactor_table['TTS'] = TTS.map(lambda x:eval(x))
        except ModuleNotFoundError as E:
            print(RplGenError('ImportErr',E))
            sys.exit(2) # 缺乏依赖包，异常退出
        except ValueError as E: # 非法音源名
            print(E)
            sys.exit(2) # 包含非法音源名，异常退出

        # 载入od文件
        try:
            object_define_text = open(args.MediaObjDefine,'r',encoding='utf-8').read()#.split('\n')
        except UnicodeDecodeError as E:
            print(DecodeError('DecodeErr',E))
            sys.exit(2) # 解码角色配置表错误，异常退出
        if object_define_text[0] == '\ufeff': # UTF-8 BOM
            print(WarningPrint('UFT8BOM'))
            object_define_text = object_define_text[1:]
        object_define_text = object_define_text.split('\n')
        
        for i,text in enumerate(object_define_text):
            if text == '':
                continue
            elif text[0] == '#':
                continue
            else:
                try:
                    obj_name = text.split('=')[0]
                    obj_name = obj_name.replace(' ','')
                    if obj_name in occupied_variable_name:
                        raise SyntaxsError('OccName')
                    elif (len(re.findall('\w+',obj_name))==0)|(obj_name[0].isdigit()):
                        raise SyntaxsError('InvaName')
                    media_list.append(obj_name) #记录新增对象名称
                except Exception as E:
                    print(E)
                    print(SyntaxsError('MediaDef',text,str(i+1)))
                    sys.exit(2) # 媒体定义文件格式错误，异常退出

        # 载入log文件
        try:
            stdin_text = open(args.LogFile,'r',encoding='utf-8').read()#.split('\n')
        except UnicodeDecodeError as E:
            print(DecodeError('DecodeErr',E))
            sys.exit(2) # 解码log文件错误，异常退出！
        if stdin_text[0] == '\ufeff': # 139 debug
            print(WarningPrint('UFT8BOM'))
            stdin_text = stdin_text[1:]
        stdin_text = stdin_text.split('\n')
        try:
            asterisk_line = parser(stdin_text)
        except Exception as E:
            print(E)
            sys.exit(2) # 解析log错误，异常退出！

        asterisk_line['synth_status'] = False # v1.6.1 初始值，以免生成refresh的时候报错！
        fatal_break = False # 是否发生中断？
        # 开始合成
        print(SynthPrint('SthBegin'))
        for key,value in asterisk_line.iterrows():
            # 进行合成
            ofile_path,synth_status = synthesizer(key,value)
            if ofile_path == 'Keep':
                pass
            elif ofile_path == 'None':
                asterisk_line.loc[key,'filepath'] = synth_status
            elif ofile_path == 'Fatal':
                asterisk_line.loc[key,'filepath'] = synth_status
                fatal_break = True
                print(SynthesisError('FatalError'))
                break
            elif os.path.isfile(ofile_path)==False:
                asterisk_line.loc[key,'filepath'] = 'None'
            else:
                asterisk_line.loc[key,'filepath'] = ofile_path
            asterisk_line.loc[key,'synth_status'] = synth_status

        # 仅category 3,或者成功合成的1，2去更新标记
        refresh = asterisk_line[(asterisk_line.category==3)|(asterisk_line.synth_status==True)].dropna().copy() #检定是否成功合成

        if len(refresh.index) == 0: #如果未合成任何语音
            if fatal_break == True:
                print(WarningPrint('SynthNBegin'))
                sys.exit(2) # 在第一行就终止
            else:
                print(WarningPrint('No2Synth'))
                sys.exit(1) # 未有合成，警告退出

        # 原始log文件备份到输出路径
        backup_log = args.OutputPath+'/OriginalLogfileBackup_'+mod62_timestamp()+'.rgl'
        backup_logfile = open(backup_log,'w',encoding='utf-8')
        backup_logfile.write('\n'.join(stdin_text))
        backup_logfile.close()
        print(SynthPrint('OriBack',backup_log))

        # 读取音频时长
        for key,value in refresh.iterrows():
            try:
                refresh.loc[key,'audio_lenth'] = Audio(value.filepath).get_length()
            except MediaError as E:
                print(WarningPrint('BadAuLen', str(value.filepath), E))
                refresh.loc[key,'audio_lenth'] = np.nan

        # 生成新的标签
        new_asterisk_label = "{'"+refresh.filepath + "';*"+refresh.audio_lenth.map(lambda x:'%.3f'%x)+"}"
        refresh['new_asterisk_label'] = new_asterisk_label

        # 替换原来的标签
        for key,value in refresh.iterrows():
            stdin_text[key] = stdin_text[key].replace(value.asterisk_label,value.new_asterisk_label)

        # 覆盖原始log文件
        stdout_logfile = open(args.LogFile,'w',encoding='utf-8')
        stdout_logfile.write('\n'.join(stdin_text))
        stdout_logfile.close()
        print(SynthPrint('Refresh'))

        if fatal_break == True:
            print(SynthPrint('Breaked'))
            sys.exit(3)
        else:
            print(SynthPrint('Done'))

    if __name__ == '__main__':
        if args.PreviewOnly == True:
            open_Tuning_windows(init_type=args.Init)
        else:
            main()

elif args.Modules == 'export_xml':
    from core.Exceptions import RplGenError, Print
    from core.Exceptions import ArgumentError, DecodeError, MediaError, SyntaxsError
    from core.Exceptions import PrxmlPrint, WarningPrint
    media_obj = args.MediaObjDefine #媒体对象定义文件的路径
    char_tab = args.CharacterTable #角色和媒体对象的对应关系文件的路径
    stdin_log = args.TimeLine #log路径
    output_path = args.OutputPath #保存的时间轴，断点文件的目录

    screen_size = (args.Width,args.Height) #显示的分辨率
    frame_rate = args.FramePerSecond #帧率 单位fps
    zorder = args.Zorder.split(',') #渲染图层顺序

    # 初始化日志打印
    if args.Language == 'zh':
        # 中文
        Print.lang = 1 
        RplGenError.lang = 1
    else:
        # 英文
        Print.lang == 0
        RplGenError.lang = 0

    try:
        for path in [stdin_log,media_obj]:
            if path is None:
                raise ArgumentError('MissInput')
            if os.path.isfile(path) == False:
                raise ArgumentError('FileNotFound',path)

        if output_path is None:
            pass 
        elif os.path.isdir(output_path) == False:
            try:
                os.makedirs(output_path)
            except Exception:
                raise ArgumentError('MkdirErr',output_path)
        output_path = output_path.replace('\\','/')

        # FPS
        if frame_rate <= 0:
            raise ArgumentError('FrameRate',str(frame_rate))
        elif frame_rate>30:
            print(WarningPrint('HighFPS',str(frame_rate))) 

        if (screen_size[0]<=0) | (screen_size[1]<=0):
            raise ArgumentError('Resolution',str(screen_size))
        if screen_size[0]*screen_size[1] > 3e6:
            print(WarningPrint('HighRes')) 
    except Exception as E:
        print(E)
        sys.exit(1)

    # 包导入

    import pandas as pd
    import numpy as np
    from PIL import Image,ImageFont,ImageDraw
    import re
    from pygame import mixer
    import glob # 匹配路径
    import pickle

    from core.FreePos import Pos,FreePos,PosGrid

    # 文字对象

    outtext_index = 0
    outanime_index = 0 
    clip_index = 0
    file_index = 0

    class Text:
        def __init__(self,fontfile='./media/SourceHanSansCN-Regular.otf',fontsize=40,color=(0,0,0,255),line_limit=20,label_color='Lavender'):
            self.color=color
            self.size=fontsize
            self.line_limit = line_limit
            self.fontpath = fontfile
            self.label_color = label_color
        def render(self,tx):
            font_this = ImageFont.truetype(self.fontpath, self.size)
            text_this = Image.new(mode='RGBA',size=(self.size*int(len(tx)*1.5),self.size*2),color=(0,0,0,0)) # 画布贪婪为2x高度，1.5*宽度
            draw_this = ImageDraw.Draw(text_this)
            draw_this.text((0,0),tx,font = font_this,align ="left",fill = self.color)
            return text_this
        def draw(self,text):
            out_text = []
            if ('#' in text) | (text[0]=='^'): #如果有手动指定的换行符
                if text[0]=='^': # 如果使用^指定的手动换行，则先去掉这个字符。
                    text = text[1:]
                text_line = text.split('#')
                for tx in text_line:
                    out_text.append(self.render(tx))
            elif len(text) > self.line_limit: #如果既没有主动指定，字符长度也超限
                ceil_div = lambda x,y: -(-x//y)
                for i in range(0,ceil_div(len(text),self.line_limit)):
                    out_text.append(self.render(text[i*self.line_limit:(i+1)*self.line_limit]))
            else:
                out_text = [self.render(text)]
            return out_text
        def convert(self):
            pass

    class StrokeText(Text):
        def __init__(self,fontfile='./media/SourceHanSansCN-Regular.otf',fontsize=40,color=(0,0,0,255),line_limit=20,edge_color=(255,255,255,255),edge_width=1,label_color='Lavender'):
            super().__init__(fontfile=fontfile,fontsize=fontsize,color=color,line_limit=line_limit,label_color=label_color) # 继承
            self.edge_color=edge_color
            try:
                self.edge_width = int(edge_width)
            except ValueError:
                raise MediaError("InvEgWd",edge_width)
            if self.edge_width < 0:
                raise MediaError("InvEgWd",edge_width)
            elif self.edge_width > 3:
                print(WarningPrint('WideEdge'))
        def render(self,tx):
            ew = self.edge_width
            font_this = ImageFont.truetype(self.fontpath, self.size)
            text_this = Image.new(mode='RGBA',size=(self.size*int(len(tx)*1.5)+2*ew,self.size*2+2*ew),color=(0,0,0,0)) # 画布贪婪为2x高度，1.5*宽度
            draw_this = ImageDraw.Draw(text_this)
            # 角
            for pos in [[0,0],[0,2*ew],[2*ew,0],[2*ew,2*ew]]:
                draw_this.text(pos,tx,font = font_this,align ="left",fill = self.edge_color)
            # 边
            for i in range(1,ew*2):
                for pos in [[0,i],[i,0],[2*ew,i],[i,2*ew]]:
                    draw_this.text(pos,tx,font = font_this,align ="left",fill = self.edge_color)
            # 中心
            draw_this.text((ew,ew),tx,font = font_this,align ="left",fill = self.color)
            return text_this

        # 对话框、气泡、文本框
    class Bubble:
        def __init__(self,filepath=None,Main_Text=Text(),Header_Text=None,pos=(0,0),mt_pos=(0,0),ht_pos=(0,0),ht_target='Name',align='left',line_distance=1.5,label_color='Lavender'):
            global file_index
            # 支持气泡图缺省
            if filepath is None or filepath == 'None':
                self.path = None
                self.media = None
                self.size = screen_size
                self.filename = None
            else:
                self.path = reformat_path(filepath)
                self.media = Image.open(filepath).convert('RGBA')
                self.size = self.media.size
                self.filename = self.path.split('/')[-1]
            # pos
            if type(pos) in [Pos,FreePos]:
                self.pos = pos
            else:
                self.pos = Pos(*pos)
            # Text
            self.MainText = Main_Text
            self.mt_pos = mt_pos
            self.Header = Header_Text
            self.ht_pos = ht_pos
            self.target = ht_target
            self.line_distance = line_distance
            self.align = align
            # clip
            self.fileindex = 'BBfile_' + '%d'% file_index
            self.label_color = label_color
            file_index = file_index+1
        # return a canvas
        def draw(self, text, header=''):
            # 生成文本图片
            # ofile = output_path+'/auto_TX_%d'%outtext_index+'.png'
            canvas = Image.new(mode='RGBA',size=self.size,color=(0,0,0,0))
            if (self.Header!=None) & (header!=''):    # Header 有定义，且输入文本不为空
                ht_text = self.Header.draw(header)[0]
                try:
                    p1,p2,p3,p4 = ht_text.getbbox() # 如果是空图的话，getbbox返回None，会发生TypeError
                    canvas.paste(ht_text.crop((p1,p2,p3,p4)),(self.ht_pos[0]+p1,self.ht_pos[1]+p2)) # 兼容微软雅黑这种，bbox到处飘的字体
                except TypeError:
                    pass
            x,y = self.mt_pos
            for i,mt_text in enumerate(self.MainText.draw(text)):
                try:
                    p1,p2,p3,p4 = mt_text.getbbox() # 先按照bboxcrop，然后按照原位置放置
                except TypeError: # 如果遇到了空图导致的TypeError，直接跳过这一循环，走到下一行
                    continue
                if self.align == 'left':
                    canvas.paste(mt_text.crop((p1,p2,p3,p4)),(x+p1,int(y+i*self.MainText.size*self.line_distance+p2)))
                else: # alpha 1.7.0 兼容居中
                    word_w = p3 - p1
                    canvas.paste(mt_text.crop((p1,p2,p3,p4)),
                                (x + (self.MainText.size*self.MainText.line_limit - word_w)//2,
                                int(y+i*self.MainText.size*self.line_distance+p2)
                                )
                                )
            # canvas.save(ofile)
            return canvas
        def display(self,begin,end,text,header='',center='NA'): # 这段代码是完全没有可读性的屎，但是确实可运行，非必要不要改
            global outtext_index,clip_tplt,clip_index
            if center == 'NA':
                self.PRpos = PR_center_arg(np.array(self.size),np.array(self.pos.get()))
            else:
                self.PRpos = PR_center_arg(np.array(self.size),np.array(Pos(*eval(center)).get()))
            
            ofile = output_path+'/auto_TX_%d'%outtext_index+'.png'
            canvas_draw = self.draw(text,header)
            canvas_draw.save(ofile)
            
            # 生成序列
            width,height = self.size
            pr_horiz,pr_vert = self.PRpos
            if self.path is None:
                clip_bubble = None
                # print('Render empty Bubble!')
            else:
                clip_bubble = clip_tplt.format(**{'clipid':'BB_clip_%d'%clip_index,
                                                'clipname':self.filename,
                                                'timebase':'%d'%frame_rate,
                                                'ntsc':Is_NTSC,
                                                'start':'%d'%begin,
                                                'end':'%d'%end,
                                                'in':'%d'%90000,
                                                'out':'%d'%(90000+end-begin),
                                                'fileid':self.fileindex,
                                                'filename':self.filename,
                                                'filepath':self.path,
                                                'filewidth':'%d'%width,
                                                'fileheight':'%d'%height,
                                                'horiz':'%.5f'%pr_horiz,
                                                'vert':'%.5f'%pr_vert,
                                                'colorlabel':self.label_color})
            clip_text = clip_tplt.format(**{'clipid':'TX_clip_%d'%clip_index,
                                            'clipname':'auto_TX_%d.png'%outtext_index,
                                            'timebase':'%d'%frame_rate,
                                            'ntsc':Is_NTSC,
                                            'start':'%d'%begin,
                                            'end':'%d'%end,
                                            'in':'%d'%90000,
                                            'out':'%d'%(90000+end-begin),
                                            'fileid':'auto_TX_%d'%outtext_index,
                                            'filename':'auto_TX_%d.png'%outtext_index,
                                            'filepath':reformat_path(ofile),
                                            'filewidth':'%d'%width,
                                            'fileheight':'%d'%height,
                                            'horiz':'%.5f'%pr_horiz,
                                            'vert':'%.5f'%pr_vert,
                                            'colorlabel':self.MainText.label_color})
            outtext_index = outtext_index + 1
            clip_index = clip_index+1
            return (clip_bubble,clip_text)

        def convert(self):
            pass

    class Balloon(Bubble):
        def __init__(self,filepath=None,Main_Text=Text(),Header_Text=[None],pos=(0,0),mt_pos=(0,0),ht_pos=[(0,0)],ht_target=['Name'],align='left',line_distance=1.5,label_color='Lavender'):
            super().__init__(filepath=filepath,Main_Text=Main_Text,Header_Text=Header_Text,pos=pos,mt_pos=mt_pos,ht_pos=ht_pos,ht_target=ht_target,align=align,line_distance=line_distance,label_color=label_color)
            if len(self.Header)!=len(self.ht_pos) or len(self.Header)!=len(self.target):
                raise MediaError('BnHead')
            else:
                self.header_num = len(self.Header)
        def draw(self, text, header=''):
            # 生成文本图片 # 同Bubble类
            canvas = Image.new(mode='RGBA',size=self.size,color=(0,0,0,0))
            # 生成头文本
            header_texts = header.split('|')
            for i,header_text_this in enumerate(header_texts):
                # Header 不为None ，且输入文本不为空
                if (self.Header[i]!=None) & (header_text_this!=''):
                    ht_text = self.Header[i].draw(header_text_this)[0]
                    try:
                        p1,p2,p3,p4 = ht_text.getbbox()
                        canvas.paste(ht_text.crop((p1,p2,p3,p4)),(self.ht_pos[i][0]+p1,self.ht_pos[i][1]+p2)) # 兼容微软雅黑这种，bbox到处飘的字体
                    except TypeError:
                        pass
                if i == self.header_num -1:
                    break
            # 生成主文本 # 同Bubble类
            x,y = self.mt_pos
            for i,mt_text in enumerate(self.MainText.draw(text)):
                try:
                    p1,p2,p3,p4 = mt_text.getbbox() # 先按照bboxcrop，然后按照原位置放置
                except TypeError: # 如果遇到了空图导致的TypeError，直接跳过这一循环，走到下一行
                    continue
                if self.align == 'left':
                    canvas.paste(mt_text.crop((p1,p2,p3,p4)),(x+p1,int(y+i*self.MainText.size*self.line_distance+p2)))
                else: # alpha 1.7.0 兼容居中
                    word_w = p3 - p1
                    canvas.paste(mt_text.crop((p1,p2,p3,p4)),
                                (x + (self.MainText.size*self.MainText.line_limit - word_w)//2,
                                int(y+i*self.MainText.size*self.line_distance+p2)
                                )
                                )
            return canvas

    class DynamicBubble(Bubble):
        def __init__(self,filepath=None,Main_Text=Text(),Header_Text=None,pos=(0,0),mt_pos=(0,0),mt_end=(0,0),ht_pos=(0,0),ht_target='Name',fill_mode='stretch',line_distance=1.5,label_color='Lavender'):
            super().__init__(filepath=filepath,Main_Text=Main_Text,Header_Text=Header_Text,pos=pos,mt_pos=mt_pos,ht_pos=ht_pos,ht_target=ht_target,line_distance=line_distance,label_color=label_color)
            if (mt_pos[0] >= mt_end[0]) | (mt_pos[1] >= mt_end[1]) | (mt_end[0] > self.size[0]) | (mt_end[1] > self.size[1]):
                raise MediaError('InvSep','mt_end')
            elif (mt_pos[0] < 0) | (mt_pos[1] < 0):
                raise MediaError('InvSep','mt_pos')
            else:
                self.mt_end = mt_end
            # fill_mode 只能是 stretch 或者 collage
            if fill_mode in ['stretch','collage']:
                self.fill_mode = fill_mode
            else:
                raise MediaError('InvFill', fill_mode)
            # x,y轴上的四条分割线
            self.x_tick = [0,self.mt_pos[0],self.mt_end[0],self.size[0]]
            self.y_tick = [0,self.mt_pos[1],self.mt_end[1],self.size[1]]
            self.bubble_clip = []
            # 0 3 6
            # 1 4 7
            # 2 5 8
            for i in range(0,3):
                for j in range(0,3):
                    try:
                        # crop(left, upper, right, lower)
                        self.bubble_clip.append(self.media.crop((self.x_tick[i],self.y_tick[j],
                                                                self.x_tick[i+1],self.y_tick[j+1]
                                                                )))
                    except Exception:
                        # 无效的clip
                        self.bubble_clip.append(None)
            self.bubble_clip_size = list(map(lambda x:(0,0) if x is None else x.size, self.bubble_clip))

        def draw(self, text, header = ''):
            # 首先，需要把主文本渲染出来
            main_text_list = self.MainText.draw(text)
            # 第一次循环：获取最大的x和最大的y
            # 导出PR项目的特殊性：如果是一个空白文本，那么getbbox将不能得到理论尺寸。
            # 因此xlim和ylim的初始值被设为半个字的大小。
            xlim = int(self.MainText.size/2)
            ylim = self.MainText.size
            for i,mt_text in enumerate(main_text_list):
                try:
                    p1,p2,p3,p4 = mt_text.getbbox() # 先按照bboxcrop，然后按照原位置放置
                except TypeError: # 如果遇到了空图导致的TypeError，直接跳过这一循环，走到下一行
                    continue
                # 因为考虑到有的字体的bbox不对劲，因此不减去p1,p2，以p3，p4为准
                x_this = p3
                y_this = p4
                y_this = i*self.MainText.size*self.line_distance + y_this
                if x_this > xlim:
                    xlim = int(x_this)
                ylim = int(y_this)
            # 建立变形后的气泡
            temp_size_x = xlim + self.x_tick[1] + self.x_tick[3] - self.x_tick[2]
            temp_size_y = ylim + self.y_tick[1] + self.y_tick[3] - self.y_tick[2]
            bubble_canvas = Image.new(mode='RGBA',size=(temp_size_x,temp_size_y),color=(0,0,0,0))
            text_canvas = Image.new(mode='RGBA',size=(temp_size_x,temp_size_y),color=(0,0,0,0))
            # 生成文本图片
            # 头文本
            if (self.Header!=None) & (header!=''):    # Header 有定义，且输入文本不为空
                if self.ht_pos[0] > self.x_tick[2]:
                    ht_renderpos_x = self.ht_pos[0] - self.x_tick[2] + self.x_tick[1] + xlim
                else:
                    ht_renderpos_x = self.ht_pos[0]
                if self.ht_pos[1] > self.y_tick[2]:
                    ht_renderpos_y = self.ht_pos[1] - self.y_tick[2] + self.y_tick[1] + ylim
                else:
                    ht_renderpos_y = self.ht_pos[1]
                ht_text = self.Header.draw(header)[0]
                try:
                    p1,p2,p3,p4 = ht_text.getbbox() # 如果是空图的话，getbbox返回None，会发生TypeError
                    text_canvas.paste(ht_text.crop((p1,p2,p3,p4)),(ht_renderpos_x+p1,ht_renderpos_y+p2)) # 兼容微软雅黑这种，bbox到处飘的字体
                except TypeError:
                    pass
            # 主文本
            for i,mt_text in enumerate(main_text_list):
                try:
                    p1,p2,p3,p4 = mt_text.getbbox() # 先按照bboxcrop，然后按照原位置放置
                except TypeError: # 如果遇到了空图导致的TypeError，直接跳过这一循环，走到下一行
                    continue
                text_canvas.paste(mt_text.crop((p1,p2,p3,p4)),(self.x_tick[1]+p1,int(self.y_tick[1]+i*self.MainText.size*self.line_distance+p2)))

            # return ofile
            # 气泡碎片的渲染位置
            bubble_clip_pos = {
                0:(0,0),
                1:(0,self.y_tick[1]),
                2:(0,self.y_tick[1]+ylim),
                3:(self.x_tick[1],0),
                4:(self.x_tick[1],self.y_tick[1]),
                5:(self.x_tick[1],self.y_tick[1]+ylim),
                6:(self.x_tick[1]+xlim,0),
                7:(self.x_tick[1]+xlim,self.y_tick[1]),
                8:(self.x_tick[1]+xlim,self.y_tick[1]+ylim)
            }
            # 气泡碎片的目标大小
            bubble_clip_scale = {
                0:False,
                1:(self.x_tick[1],ylim),
                2:False,
                3:(xlim,self.y_tick[1]),
                4:(xlim,ylim),
                5:(xlim,self.y_tick[3]-self.y_tick[2]),
                6:False,
                7:(self.x_tick[3]-self.x_tick[2],ylim),
                8:False
            }
            for i in range(0,9):
                if 0 in self.bubble_clip_size[i]:
                    continue
                else:
                    if bubble_clip_scale[i] == False:
                        bubble_canvas.paste(self.bubble_clip[i],bubble_clip_pos[i])
                    else:
                        if self.fill_mode == 'stretch':
                            bubble_canvas.paste(self.bubble_clip[i].resize(bubble_clip_scale[i]),bubble_clip_pos[i])
                        elif self.fill_mode == 'collage':
                            # 新建拼贴图层，尺寸为气泡碎片的目标大小
                            collage_canvas = Image.new(mode='RGBA',size=bubble_clip_scale[i],color=(0,0,0,0))
                            col_x,col_y = (0,0)
                            while col_y < bubble_clip_scale[i][1]:
                                col_x = 0
                                while col_x < bubble_clip_scale[i][0]:
                                    collage_canvas.paste(self.bubble_clip[i],(col_x,col_y))
                                    col_x = col_x + self.bubble_clip_size[i][0]
                                col_y = col_y + self.bubble_clip_size[i][1]
                            bubble_canvas.paste(collage_canvas,bubble_clip_pos[i])
            # 如果气泡图是空的，则返回空
            if bubble_canvas.getbbox() is None:
                return None,text_canvas
            # 无论文本图是不是空的，均正常保存为文件。
            else:
                return bubble_canvas,text_canvas
        def display(self,begin,end,text,header='',center='NA'): # 这段代码是完全没有可读性的屎，但是确实可运行，非必要不要改
            global outtext_index,clip_tplt,clip_index
            # 先生成文件
            bubble_ofile = output_path+'/auto_BB_%d'%outtext_index+'.png'
            text_ofile = output_path+'/auto_TX_%d'%outtext_index+'.png'

            bubble_canvas,text_canvas = self.draw(text,header)
            temp_size = text_canvas.size

            # 保存文件
            text_canvas.save(text_ofile)

            # 获取动态气泡的参数
            width,height = temp_size
            # 获取PR位置参数
            if center == 'NA':
                self.PRpos = PR_center_arg(np.array(temp_size),np.array(self.pos.get()))
            else:
                self.PRpos = PR_center_arg(np.array(temp_size),np.array(Pos(*eval(center)).get()))
            pr_horiz,pr_vert = self.PRpos
            # 生成序列
            if bubble_canvas is None:
                clip_bubble = None
                # print('Render empty Bubble!')
            else:
                # 先保存气泡图片
                bubble_canvas.save(bubble_ofile)
                clip_bubble = clip_tplt.format(**{'clipid':'BB_clip_%d'%clip_index,
                                                'clipname':'auto_BB_%d.png'%outtext_index,
                                                'timebase':'%d'%frame_rate,
                                                'ntsc':Is_NTSC,
                                                'start':'%d'%begin,
                                                'end':'%d'%end,
                                                'in':'%d'%90000,
                                                'out':'%d'%(90000+end-begin),
                                                'fileid':'auto_BB_%d'%outtext_index,
                                                'filename':'auto_BB_%d.png'%outtext_index,
                                                'filepath':reformat_path(bubble_ofile),
                                                'filewidth':'%d'%width,
                                                'fileheight':'%d'%height,
                                                'horiz':'%.5f'%pr_horiz,
                                                'vert':'%.5f'%pr_vert,
                                                'colorlabel':self.label_color})
            # tx的clip
            clip_text = clip_tplt.format(**{'clipid':'TX_clip_%d'%clip_index,
                                            'clipname':'auto_TX_%d.png'%outtext_index,
                                            'timebase':'%d'%frame_rate,
                                            'ntsc':Is_NTSC,
                                            'start':'%d'%begin,
                                            'end':'%d'%end,
                                            'in':'%d'%90000,
                                            'out':'%d'%(90000+end-begin),
                                            'fileid':'auto_TX_%d'%outtext_index,
                                            'filename':'auto_TX_%d.png'%outtext_index,
                                            'filepath':reformat_path(text_ofile),
                                            'filewidth':'%d'%width,
                                            'fileheight':'%d'%height,
                                            'horiz':'%.5f'%pr_horiz,
                                            'vert':'%.5f'%pr_vert,
                                            'colorlabel':self.MainText.label_color})
            outtext_index = outtext_index + 1
            clip_index = clip_index+1
            return (clip_bubble,clip_text)

    class ChatWindow(Bubble):
        def __init__(self,filepath=None,sub_key=['Key1'],sub_Bubble=[Bubble()],sub_Anime=[],sub_align=['left'],pos=(0,0),sub_pos=(0,0),sub_end=(0,0),am_left=0,am_right=0,sub_distance=50,label_color='Lavender'):
            global file_index
            if len(sub_Bubble) != len(sub_key):
                raise MediaError('CWKeyLen')
            # 空白底图
            if filepath is None or filepath == 'None':
                self.path = None
                self.media = None
                self.size = screen_size
                self.filename = None
            else:
                self.path = reformat_path(filepath)
                self.media = Image.open(filepath).convert('RGBA')
                self.size = self.media.size
                self.filename = self.path.split('/')[-1]
            # 位置
            if type(pos) in [Pos,FreePos]:
                self.pos = pos
            else:
                self.pos = Pos(*pos)
            # 子气泡和对齐
            self.sub_Bubble = {}
            self.sub_Anime = {}
            self.sub_align = {}
            for i,key in enumerate(sub_key):
                # 检查气泡是否是 Ballon
                if type(sub_Bubble[i]) is Balloon:
                    raise MediaError('Bn2CW', key)
                self.sub_Bubble[key] = sub_Bubble[i]
                # 载入对齐，默认是左对齐
                try:
                    if sub_align[i] in ['left','right']:
                        self.sub_align[key] = sub_align[i]
                    else:
                        raise MediaError('BadAlign',sub_align[i])
                except IndexError:
                    self.sub_align[key] = 'left'
                # 载入子立绘，默认是None
                try:
                    self.sub_Anime[key] = sub_Anime[i]
                except IndexError:
                    self.sub_Anime[key] = None
            # 子气泡尺寸
            if (sub_pos[0] >= sub_end[0]) | (sub_pos[1] >= sub_end[1]):
                raise MediaError('InvSep','sub_end')
            else:
                self.sub_size = (sub_end[0]-sub_pos[0],sub_end[1]-sub_pos[1])
                self.sub_pos = sub_pos
            # 立绘对齐位置
            if am_left >= am_right:
                raise MediaError('InvSep', 'am_right')
            else:
                self.am_left = am_left
                self.am_right = am_right
            # 子气泡间隔
            self.sub_distance = sub_distance
            # 留存文本容器-这边应该用不到：
            self.main_text = ''
            self.header_text = ''
            # 其他气泡类clip的必要参数
            self.fileindex = 'BBfile_' + '%d'% file_index
            self.label_color = label_color
            # 这个MainText只是用来给labelcolor做参考用的。
            self.MainText = self.sub_Bubble[sub_key[0]].MainText
            file_index = file_index+1

        # 渲染气泡中的文本，对于CW来说，包括子气泡的窗体和PC头像都在这里生成。
        def draw(self, text, header=''):
            # 生成文本图片
            ofile = output_path+'/auto_TX_%d'%outtext_index+'.png'
            # 主容器，容纳整个文本图
            canvas = Image.new(mode='RGBA',size=self.size,color=(0,0,0,0))
            # 子气泡容器，容纳若干个子气泡及其文本
            sub_canvas = Image.new(mode='RGBA',size=self.sub_size,color=(0,0,0,0))
            # 立绘容器，容纳若干个立绘
            am_canvas = Image.new(mode='RGBA',size=(self.am_right-self.am_left,self.sub_size[1]),color=(0,0,0,0))
            # 拆分主文本和头文本
            main_text_list = text.split('|')
            header_text_list = header.split('|')
            header_main_pair = []
            for i,main_text in enumerate(main_text_list):
                header_main_pair.append((header_text_list[i],main_text))
            # 将头主文本对列表倒序
            header_main_pair = header_main_pair[::-1]
            # 第二次循环：渲染子气泡
            y_bottom = self.sub_size[1] # 当前句子的可用y底部
            for header_main in header_main_pair:
                # 解析(键#头文本,主文本)
                bubble_header_this,main_this = header_main
                key_this,header_this = bubble_header_this.split('#')
                # 绘制子气泡
                if type(self.sub_Bubble[key_this]) is DynamicBubble:
                    bubble_canvas,text_canvas = self.sub_Bubble[key_this].draw(main_this,header_this)
                else:
                    text_canvas = self.sub_Bubble[key_this].draw(main_this,header_this)
                    bubble_canvas = self.sub_Bubble[key_this].media
                if bubble_canvas is not None:
                    bubble_canvas.paste(text_canvas,(0,0),mask=text_canvas)
                    subbubble_canvas = bubble_canvas
                else:
                    subbubble_canvas = text_canvas
                subbubble_size = subbubble_canvas.size
                if self.sub_align[key_this] == 'left':
                    sub_canvas.paste(subbubble_canvas,(0,y_bottom-subbubble_size[1]))
                    if self.sub_Anime[key_this] is not None:
                        am_canvas.paste(self.sub_Anime[key_this].media,(0,y_bottom-subbubble_size[1]))
                else:
                    sub_canvas.paste(subbubble_canvas,(self.sub_size[0]-subbubble_size[0],y_bottom-subbubble_size[1]))
                    if self.sub_Anime[key_this] is not None:
                        am_canvas.paste(self.sub_Anime[key_this].media,(self.am_right-self.am_left-self.sub_Anime[key_this].size[0],y_bottom-subbubble_size[1]))
                # 更新可用底部 = 前一次底部 - 子气泡高度 - 子气泡间距
                y_bottom = y_bottom - subbubble_size[1] - self.sub_distance
                # 如果可用底部已经达到顶部之外
                if y_bottom < 0:
                    break            
            # 将子气泡容器渲染到母气泡容器
            canvas.paste(sub_canvas,self.sub_pos)
            canvas.paste(am_canvas,(self.am_left,self.sub_pos[1]),mask=am_canvas)
            return canvas

    # 背景图片
    class Background:
        def __init__(self,filepath,pos = (0,0),label_color='Lavender'):
            global file_index 
            # 对纯色定义的背景的支持
            if filepath in cmap.keys():
                # 新建图像，并保存
                ofile = output_path+'/auto_BG_'+filepath+'.png'
                self.media = Image.new(mode='RGBA',size=screen_size,color=cmap[filepath])
                self.media.save(ofile)
                # 路径和尺寸
                self.path = reformat_path(ofile)
                self.size = screen_size
            else:
                self.path = reformat_path(filepath)
                self.media = Image.open(filepath).convert('RGBA')
                self.size = self.media.size
            if type(pos) in [Pos,FreePos]:
                self.pos = pos
            else:
                self.pos = Pos(*pos)
            # self.PRpos = PR_center_arg(np.array(self.size),np.array(self.pos.get()))
            self.filename = self.path.split('/')[-1]
            self.fileindex = 'BGfile_%d'% file_index
            self.label_color = label_color
            file_index = file_index+1
        def display(self,begin,end,center='NA'):
            global clip_tplt,clip_index
            if center == 'NA':
                self.PRpos = PR_center_arg(np.array(self.size),np.array(self.pos.get()))
            else:
                self.PRpos = PR_center_arg(np.array(self.size),np.array(Pos(*eval(center)).get()))
            width,height = self.size
            pr_horiz,pr_vert = self.PRpos
            clip_this = clip_tplt.format(**{'clipid':'BG_clip_%d'%clip_index,
                                'clipname':self.filename,
                                'timebase':'%d'%frame_rate,
                                'ntsc':Is_NTSC,
                                'start':'%d'%begin,
                                'end':'%d'%end,
                                'in':'%d'%90000,
                                'out':'%d'%(90000+end-begin),
                                'fileid':self.fileindex,
                                'filename':self.filename,
                                'filepath':self.path,
                                'filewidth':'%d'%width,
                                'fileheight':'%d'%height,
                                'horiz':'%.5f'%pr_horiz,
                                'vert':'%.5f'%pr_vert,
                                'colorlabel':self.label_color})
            clip_index = clip_index+1
            return clip_this
        def convert(self):
            pass

    # 立绘图片
    class Animation:
        def __init__(self,filepath,pos = (0,0),tick=1,loop=True,label_color='Lavender'):
            global file_index 
            self.path = reformat_path(glob.glob(filepath)[0]) # 兼容动画Animation，只使用第一帧！
            self.media = Image.open(glob.glob(filepath)[0].replace('\\','/')).convert('RGBA')
            self.size = self.media.size
            self.filename = self.path.split('/')[-1]
            if type(pos) in [Pos,FreePos]:
                self.pos = pos
            else:
                self.pos = Pos(*pos)
            self.fileindex = 'AMfile_%d'% file_index
            # self.PRpos = PR_center_arg(np.array(self.size),np.array(self.pos.get()))
            self.label_color = label_color
            file_index = file_index+1
        def display(self,begin,end,center='NA'):
            global clip_tplt,clip_index
            if center == 'NA':
                self.PRpos = PR_center_arg(np.array(self.size),np.array(self.pos.get()))
            else:
                self.PRpos = PR_center_arg(np.array(self.size),np.array(Pos(*eval(center)).get()))
            width,height = self.size
            pr_horiz,pr_vert = self.PRpos
            clip_this = clip_tplt.format(**{'clipid':'AM_clip_%d'%clip_index,
                                'clipname':self.filename,
                                'timebase':'%d'%frame_rate,
                                'ntsc':Is_NTSC,
                                'start':'%d'%begin,
                                'end':'%d'%end,
                                'in':'%d'%90000,
                                'out':'%d'%(90000+end-begin),
                                'fileid':self.fileindex,
                                'filename':self.filename,
                                'filepath':self.path,
                                'filewidth':'%d'%width,
                                'fileheight':'%d'%height,
                                'horiz':'%.5f'%pr_horiz,
                                'vert':'%.5f'%pr_vert,
                                'colorlabel':self.label_color})
            clip_index = clip_index+1
            return clip_this
        def convert(self):
            pass

    # a 1.13.5 组合立绘，Animation类的子类，组合立绘只能是静态立绘！
    class GroupedAnimation(Animation):
        def __init__(self,subanimation_list,subanimation_current_pos=None,label_color='Mango'):
            global file_index,outanime_index
            ofile = output_path+'/auto_GA_%d'%outanime_index+'.png'
            canvas = Image.new(size=screen_size,mode='RGBA',color=(0,0,0,0))
            # 如果外部未指定位置参数，则使用子Animation类的自身的pos
            if subanimation_current_pos is None:
                subanimation_current_pos = [None]*len(subanimation_list)
            # 如果指定的位置参数和子Animation的数量不一致，报出报错
            elif len(subanimation_current_pos) != len(subanimation_list):
                raise MediaError('GAPrame')
            # 开始在画板上绘制立绘
            else:
                # 越后面的位于越上层的图层
                # [zhang,drink_left] [(0,0),(0,0)] # list of Animation/str | list of tuple/str
                for am_name,am_pos in zip(subanimation_list,subanimation_current_pos):
                    # 判断AM
                    try:
                        if type(am_name) in [Animation,BuiltInAnimation,GroupedAnimation]:
                            subanimation = am_name
                        else: # type(am_name) is str
                            subanimation = eval(am_name)
                    except NameError as E:
                        raise MediaError('Undef2GA', am_name )
                    if am_pos is None:
                        # 打开 subanimation 的图片对象，将其按照self.pos, paste到canvas
                        canvas.paste(subanimation.media,subanimation.pos.get(),mask=subanimation.media)
                    else:
                        # 打开 subanimation 的图片对象，将其按照am_pos, paste到canvas
                        canvas.paste(subanimation.media,am_pos,mask=subanimation.media)
            # 保存文件
            canvas.save(ofile)
            self.pos = Pos(0,0)
            self.path = reformat_path(ofile)
            self.size = screen_size
            self.filename = 'auto_GA_%d'%outanime_index+'.png'
            self.fileindex = 'AMfile_%d'% file_index
            self.label_color = label_color
            file_index = file_index+1
            outanime_index = outanime_index+1
    # a1.6.5 内建动画，这是一个Animation类的子类，重构了构造函数
    class BuiltInAnimation(Animation):
        def __init__(self,anime_type='hitpoint',anime_args=('0',0,0,0),screensize = (1920,1080),layer=0,label_color='Mango'):
            global file_index,outanime_index
            self.label_color = label_color
            if anime_type == 'hitpoint':
                # 载入图片
                heart = Image.open('./media/heart.png')
                heart_shape = Image.open('./media/heart_shape.png')
                hx,hy = heart.size
                # 重设图片尺寸，根据screensize[0]
                if screensize[0]!=1920:
                    multip = screensize[0]/1920
                    heart = heart.resize((int(hx*multip),int(hy*multip)))
                    heart_shape = heart_shape.resize((int(hx*multip),int(hy*multip)))
                    hx,hy = heart.size
                # 动画参数
                name_tx,heart_max,heart_begin,heart_end = anime_args
                if (heart_end==heart_begin)|(heart_max<max(heart_begin,heart_end)):
                    raise MediaError('[BIAnimeError]:','Invalid argument',name_tx,heart_max,heart_begin,heart_end,'for BIAnime hitpoint!')
                elif heart_end > heart_begin: # 如果是生命恢复
                    temp = heart_end
                    heart_end = heart_begin
                    heart_begin = temp # 则互换顺序 确保 begin一定是小于end的

                distance = int(0.026*screensize[0]) # default = 50

                total_heart = int(heart_max/2 * hx + max(0,np.ceil(heart_max/2-1)) * distance) #画布总长
                left_heart = int(heart_end/2 * hx + max(0,np.ceil(heart_end/2-1)) * distance) #画布总长
                lost_heart = int((heart_begin-heart_end)/2 * hx + np.floor((heart_begin-heart_end)/2) * distance)
                # 姓名文本
                BIA_text = ImageFont.truetype('./media/SourceHanSerifSC-Heavy.otf', int(0.0521*screensize[0])) # 1080p:size=100
                test_canvas = Image.new(mode='RGBA',size=screensize,color=(0,0,0,0))
                test_draw = ImageDraw.Draw(test_canvas)
                test_draw.text((0,0), name_tx, font = BIA_text, align ="left",fill = (255,255,255,255))
                try:
                    p1,p2,p3,p4 = test_canvas.getbbox()
                except TypeError:
                    p1,p2,p3,p4 = (0,0,1,int(0.0521*screensize[0])) # nx=1 ny =fontsize
                nx = p3 - p1
                ny = p4 - p2
                nametx_surf = test_canvas.crop((p1,p2,p3,p4))
                # 开始制图
                if layer==0: # 底层 阴影图
                    self.pos = Pos((screensize[0]-max(nx,total_heart))/2,(4/5*screensize[1]-hy-ny)/2)
                    canvas = Image.new(size=(max(nx,total_heart),hy+ny+screensize[1]//5),mode='RGBA',color=(0,0,0,0))
                    self.size = canvas.size
                    if nx > total_heart:
                        canvas.paste(nametx_surf,(0,0))
                        posx = (nx-total_heart)//2
                    else:
                        canvas.paste(nametx_surf,((total_heart-nx)//2,0))
                        posx = 0
                    posy = ny+screensize[1]//5
                    for i in range(1,heart_max+1): # 偶数，低于最终血量
                        if i%2 == 0:
                            canvas.paste(heart_shape,(posx,posy))
                            posx = posx + hx + distance
                        else:
                            pass
                    if heart_max%2 == 1: # max是奇数
                        left_heart_shape = heart_shape.crop((0,0,int(hx/2),hy))
                        canvas.paste(left_heart_shape,(total_heart-int(hx/2),posy))
                elif layer==1: # 剩余的血量
                    self.pos = Pos((screensize[0]-total_heart)/2,3/5*screensize[1]+ny/2-hy/2)
                    # 1.6.5 防止报错 剩余血量即使是空图，也要至少宽30pix
                    canvas = Image.new(size=(max(30,left_heart),hy),mode='RGBA',color=(0,0,0,0)) 
                    self.size = canvas.size
                    posx,posy = 0,0
                    for i in range(1,heart_end+1): # 偶数，低于最终血量
                        if i%2 == 0:
                            canvas.paste(heart,(posx,posy))
                            posx = posx + hx + distance
                        else:
                            pass
                    if heart_end%2 == 1: # end是奇数
                        left_heart = heart.crop((0,0,int(hx/2),hy))
                        canvas.paste(left_heart,(heart_end//2*(hx + distance),0))
                elif layer==2: # 损失/恢复的血量
                    self.pos = Pos(heart_end//2*(hx + distance)+(heart_end%2)*int(hx/2)+(screensize[0]-total_heart)/2,3/5*screensize[1]+ny/2-hy/2)
                    canvas = Image.new(size=(lost_heart,hy),mode='RGBA',color=(0,0,0,0))
                    self.size = canvas.size
                    posx,posy = 0,0
                    for i in range(1,heart_begin-heart_end+1): 
                        if (i == 1)&(heart_end%2 == 1): # 如果end是奇数，先来半个右边
                            right_heart = heart.crop((int(hx/2),0,hx,hy))
                            canvas.paste(right_heart,(posx,posy))
                            posx = posx + int(hx/2) + distance
                        elif ((i - heart_end%2)%2 == 0): # 如果和end的差值是
                            canvas.paste(heart,(posx,posy))
                            posx = posx + hx + distance
                        elif (i == heart_begin-heart_end)&(heart_begin%2 == 1): # 如果最右边边也是半个心
                            left_heart = heart.crop((0,0,int(hx/2),hy))
                            canvas.paste(left_heart,(posx,posy))
                        else:
                            pass
                else:
                    pass
                ofile = output_path+'/auto_BIA_%d'%outanime_index+'.png'
                canvas.save(ofile)

                #剩下的需要定义的
                self.media = canvas
                self.path = reformat_path(ofile) # 兼容动画Animation，只使用第一帧！
                self.filename = 'auto_BIA_%d'%outanime_index+'.png'
                self.fileindex = 'AMfile_%d'% file_index
                # self.PRpos = PR_center_arg(np.array(self.size),np.array(self.pos.get()))
                outanime_index = outanime_index+1
                file_index = file_index+1
            if anime_type == 'dice':
                for die in anime_args:
                    try:
                        # 转换为int类型，NA转换为-1
                        name_tx,dice_max,dice_check,dice_face = die
                        dice_max,dice_face,dice_check = map(lambda x:-1 if x=='NA' else int(x),(dice_max,dice_face,dice_check))
                    except ValueError as E: #too many values to unpack,not enough values to unpack
                        raise MediaError('[BIAnimeError]:','Invalid syntax:',str(die),E)
                    if (dice_face>dice_max)|(dice_check<-1)|(dice_check>dice_max)|(dice_face<0)|(dice_max<=0):
                        raise MediaError('[BIAnimeError]:','Invalid argument',name_tx,dice_max,dice_check,dice_face,'for BIAnime dice!')
                N_dice = len(anime_args)
                if N_dice > 4:
                    N_dice=4
                    anime_args = anime_args[0:4]# 最多4个
                y_anchor = {4:int(0.1667*screensize[1]),3:int(0.25*screensize[1]),2:int(0.3333*screensize[1]),1:int(0.4167*screensize[1])}[N_dice]
                y_unit = int(0.1667*screensize[1])
                BIA_text = ImageFont.truetype('./media/SourceHanSerifSC-Heavy.otf', int(0.0521*screensize[0]))
                if layer==0: # 底层 名字 /检定
                    canvas = Image.new(mode='RGBA',size=screensize,color=(0,0,0,0))
                    for i,die in enumerate(anime_args): 
                        name_tx,dice_max,dice_check,dice_face = die
                        dice_max,dice_face,dice_check = map(lambda x:-1 if x=='NA' else int(x),(dice_max,dice_face,dice_check))
                        # 渲染
                        test_canvas = Image.new(mode='RGBA',size=screensize,color=(0,0,0,0))
                        test_draw = ImageDraw.Draw(test_canvas)
                        test_draw.text((0,0), name_tx, font = BIA_text, align ="left",fill = (255,255,255,255))
                        try:
                            p1,p2,p3,p4 = test_canvas.getbbox() # 重新包装为函数？
                        except TypeError:
                            p1,p2,p3,p4 = (0,0,1,int(0.0521*screensize[0])) # nx=1 ny =fontsize
                        nx = p3 - p1
                        ny = p4 - p2
                        name_surf = test_canvas.crop((p1,p2,p3,p4))
                        canvas.paste(name_surf,(int(0.3125*screensize[0])-nx//2,y_anchor+i*y_unit+(y_unit-ny)//2)) # 0.3125*screensize[0] = 600
                        if dice_check != -1:
                            test_canvas = Image.new(mode='RGBA',size=screensize,color=(0,0,0,0))
                            test_draw = ImageDraw.Draw(test_canvas)
                            test_draw.text((0,0), '/%d'%dice_check, font = BIA_text, align ="left",fill = (255,255,255,255))
                            try:
                                p1,p2,p3,p4 = test_canvas.getbbox()
                            except TypeError:
                                p1,p2,p3,p4 = (0,0,1,int(0.0521*screensize[0])) # nx=1 ny =fontsize
                            #cx = p3 - p1
                            cy = p4 - p2
                            check_surf = test_canvas.crop((p1,p2,p3,p4))
                            canvas.paste(check_surf,(int(0.7292*screensize[0]),y_anchor+i*y_unit+(y_unit-cy)//2)) # 0.7292*screensize[0] = 1400
                    self.size = screen_size
                    self.pos = Pos(0,0)
                elif layer==1: #无法显示动态，留空白
                    canvas = Image.new(mode='RGBA',size=(int(0.1458*screensize[0]),y_unit*N_dice),color=(0,0,0,0))
                    self.size = (int(0.1458*screensize[0]),y_unit*N_dice)
                    self.pos = Pos(int(0.5833*screensize[0]),y_anchor)
                elif layer==2:
                    dice_cmap={3:(124,191,85,255),1:(94,188,235,255),0:(245,192,90,255),2:(233,86,85,255),-1:(255,255,255,255)}
                    canvas = Image.new(mode='RGBA',size=(int(0.1458*screensize[0]),y_unit*N_dice),color=(0,0,0,0))
                    self.size = (int(0.1458*screensize[0]),y_unit*N_dice)
                    self.pos = Pos(int(0.5833*screensize[0]),y_anchor)
                    for i,die in enumerate(anime_args): 
                        name_tx,dice_max,dice_check,dice_face = die
                        dice_max,dice_face,dice_check = map(lambda x:-1 if x=='NA' else int(x),(dice_max,dice_face,dice_check))
                        significant = 0.05 # 大成功失败阈值
                        if dice_check == -1:
                            color_flag = -1
                        else:
                            color_flag = ((dice_face/dice_max<=significant)|(dice_face/dice_max>(1-significant)))*2 + (dice_face<=dice_check)
                        BIA_color_Text = ImageFont.truetype('./media/SourceHanSerifSC-Heavy.otf', int(0.0651*screensize[0]))
                        test_canvas = Image.new(mode='RGBA',size=(int(0.1458*screensize[0]),y_unit),color=(0,0,0,0))
                        test_draw = ImageDraw.Draw(test_canvas)
                        test_draw.text((0,0),str(dice_face),font=BIA_color_Text,align="left",fill=dice_cmap[color_flag])
                        try:
                            p1,p2,p3,p4 = test_canvas.getbbox()
                        except TypeError:
                            p1,p2,p3,p4 = (0,0,1,int(0.0651*screensize[0])) # nx=1 ny =fontsize
                        fx = p3 - p1
                        fy = p4 - p2
                        face_surf = test_canvas.crop((p1,p2,p3,p4))
                        canvas.paste(face_surf,(int(0.1458*screensize[0]-fx-0.0278*screensize[1]),i*y_unit+(y_unit-fy)//2))
                else:
                    pass
                ofile = output_path+'/auto_BIA_%d'%outanime_index+'.png'
                canvas.save(ofile)
                self.media = canvas
                self.path = reformat_path(ofile) # 兼容动画Animation，只使用第一帧！
                self.filename = 'auto_BIA_%d'%outanime_index+'.png'
                self.fileindex = 'AMfile_%d'% file_index
                # self.PRpos = PR_center_arg(np.array(self.size),np.array(self.pos.get()))
                outanime_index = outanime_index+1
                file_index = file_index+1
                
    # 音效
    class Audio:
        def __init__(self,filepath,label_color='Caribbean'):
            global file_index 
            self.path = reformat_path(filepath)
            self.filename = self.path.split('/')[-1]
            self.fileindex = 'AUfile_%d'% file_index
            self.label_color = label_color
            try:
                self.length = self.get_length(filepath)*frame_rate
            except Exception as E:
                print(WarningPrint('BadAuLen',filepath,E))
                self.length = 0
            file_index = file_index+1
            
        def display(self,begin):
            global audio_clip_tplt,clip_index
            clip_this = audio_clip_tplt.format(**{'clipid':'AU_clip_%d'%clip_index,
                                                'type':Audio_type,
                                                'clipname':self.filename,
                                                'audiolen':'%d'%self.length,
                                                'timebase':'%d'%frame_rate,
                                                'ntsc':Is_NTSC,
                                                'start':'%d'%begin,
                                                'end':'%d'%(begin+self.length),
                                                'in':'0',
                                                'out':'%d'%self.length,
                                                'fileid':self.fileindex,
                                                'filename':self.filename,
                                                'filepath':self.path,
                                                'colorlabel':self.label_color})
            clip_index = clip_index+1
            return clip_this
        def get_length(self,filepath):
            mixer.init()
            this_audio = mixer.Sound(filepath)
            return this_audio.get_length()
        def convert(self):
            pass

    # 背景音乐
    class BGM:
        def __init__(self,filepath,volume=100,loop=True,label_color='Forest'):
            print(WarningPrint('BGMIgnore',filepath))
        def convert(self):
            pass

    # 函数定义

    # 重格式化路径
    def reformat_path(path): # alpha 1.9.5 支持unix文件系统路径
        # 获取绝对路径
        path = os.path.abspath(path)
        # 检查非法符号
        if '\\' in path: #是不是反斜杠？
            path = path.replace('\\','/') 
        if ('&' in path)|('<' in path)|('>' in path):
            path = path.replace('&','&amp;').replace('<','&lt;').replace('>','&gt;') # aplha1.7.2 xml 转移的bug
        if ('"' in path)|("'" in path):
            path = path.replace('"','&quot;').replace("'",'&apos;')
        if '//' in path:
            path = path.replace('//','/')
        # 判断文件系统
        if path[0] == '/': #unix file system
            return 'file://localhost' + path
        elif (path[0].isalpha()) & (path[1]==':'): # windows disklabel
            path = path.replace(':','%3a') # 替换冒号
            return 'file://localhost/' + path
        else:
            raise ValueError('invalid path type')

    # 优化导出PR clip的逻辑：是否一定要在小节断点处分段？不分段的话会怎样？

    # 处理bg 和 am 的parser
    def parse_timeline(layer):
        global timeline,break_point
        break_at_breakpoint = ((layer[0:2]!='BG') & (layer[-1]!='S'))
        track = timeline[[layer]]
        clips = []
        item,begin,end = 'NA',0,0
        for key,values in track.iterrows():
            #如果item变化了，或者进入了指定的断点(仅断点分隔的图层)
            if (values[layer] != item) | ((key in break_point.values) & break_at_breakpoint): 
                if (item == 'NA') | (item!=item): # 如果itme是空 
                    pass # 则不输出什么
                else:
                    end = key #否则把当前key作为一个clip的断点
                    clips.append((item,begin,end)) #并记录下这个断点
                item = values[layer] #无论如何，重设item和begin
                begin = key
            else: #如果不满足断点要求，那么就什么都不做
                pass
        # 循环结束之后，最后检定一次是否需要输出一个clips
        #end = key # alpha 1.7.5 debug: 循环结束时的key有可能并不是时间轴的终点
        end = int(break_point.max()) # 因为有可能到终点为止，所有帧都是一样的，而导致被去重略去
        if (item == 'NA') | (item!=item):
            pass
        else:
            clips.append((item,begin,end))
        return clips #返回一个clip的列表

    # 处理Bb 的parser
    def parse_timeline_bubble(layer):
        global timeline,break_point
        break_at_breakpoint = ((layer[0:2]!='BG') & (layer[-1]!='S'))
        track = timeline[[layer,layer+'_main',layer+'_header']]
        clips = []
        item,begin,end = 'NA',0,0
        for key,values in track.iterrows():
            #如果item变化了，或者进入了指定的断点(这是保证断句的关键！)(仅断点分隔的图层)
            if (values[layer] != item) | ((key in break_point.values) & break_at_breakpoint): 
                if (item == 'NA') | (item!=item): # 如果itme是空 
                    pass # 则不输出什么
                else:
                    end = key #否则把当前key作为一个clip的断点
                    clips.append((item,main_text,header_text,begin,end)) #并记录下这个断点
                item = values[layer] #无论如何，重设item和begin
                # main_text = values[layer + '_main'] # v 1.10.15 这两行似乎没啥用？
                # header_text = values[layer + '_header'] # 因为下面又赋值了一遍
                begin = key
            else: #如果不满足断点要求，那么就什么都不做
                pass
            # 然后更新文本内容
            main_text = values[layer + '_main']
            header_text = values[layer + '_header']
        # 循环结束之后，最后检定一次是否需要输出一个clips
        #end = key
        end = int(break_point.max()) # alpha 1.7.5 debug: 而breakpoint的最大值一定是时间轴的终点
        if (item == 'NA') | (item!=item):
            pass
        else:
            clips.append((item,main_text,header_text,begin,end))
        return clips #返回一个clip的列表

    # pygame形式的pos转换为PR形式的pos

    def PR_center_arg(obj_size,pygame_pos):
        screensize = np.array(screen_size)
        return (pygame_pos+obj_size/2-screensize/2)/obj_size

    # 全局变量

    from core.Medias import cmap
    # cmap = {'black':(0,0,0,255),'white':(255,255,255,255),'greenscreen':(0,177,64,255)}
    Is_NTSC = str(frame_rate % 30 == 0)
    Audio_type = 'Stereo'
    stdin_name = stdin_log.replace('\\','/').split('/')[-1]
    occupied_variable_name = open('./media/occupied_variable_name.list','r',encoding='utf8').read().split('\n')

    # 载入xml 模板文件

    project_tplt = open('./xml_templates/tplt_sequence.xml','r',encoding='utf8').read()
    track_tplt = open('./xml_templates/tplt_track.xml','r',encoding='utf8').read()
    audio_track_tplt = open('./xml_templates/tplt_audiotrack.xml','r',encoding='utf8').read()
    clip_tplt = open('./xml_templates/tplt_clip.xml','r',encoding='utf8').read()
    audio_clip_tplt = open('./xml_templates/tplt_audio_clip.xml','r',encoding='utf8').read()

    # 载入timeline 和 breakpoint

    timeline_ifile = open(args.TimeLine,'rb')
    timeline,break_point,bulitin_media = pickle.load(timeline_ifile)
    timeline_ifile.close()

    def main():
        global media_list
        print(PrxmlPrint('Welcome',EDITION))
        print(PrxmlPrint('SaveAt',output_path))

        # 载入od文件
        try:
            object_define_text = open(media_obj,'r',encoding='utf-8').read()#.split('\n')
        except UnicodeDecodeError as E:
            print(DecodeError('DecodeErr', E))
            sys.exit(1)
        if object_define_text[0] == '\ufeff': # 139 debug
            print(WarningPrint('UFT8BOM'))
            object_define_text = object_define_text[1:]
        object_define_text = object_define_text.split('\n')

        media_list=[]
        for i,text in enumerate(object_define_text):
            if text == '':
                continue
            elif text[0] == '#':
                continue
            else:
                try:
                    exec(text) #对象实例化
                    obj_name = text.split('=')[0]
                    obj_name = obj_name.replace(' ','')
                    if obj_name in occupied_variable_name:
                        raise SyntaxsError('OccName')
                    elif (len(re.findall('\w+',obj_name))==0)|(obj_name[0].isdigit()):
                        raise SyntaxsError('InvaName')
                    media_list.append(obj_name) #记录新增对象名称
                except Exception as E:
                    print(E)
                    print(SyntaxsError('MediaDef',text,str(i+1)))
                    sys.exit(1)
        black = Background('black')
        white = Background('white')
        media_list.append('black')
        media_list.append('white')
        # alpha 1.6.5 载入导出的内建媒体
        for key,values in bulitin_media.iteritems():
            exec(values)
            media_list.append(key)

        # 开始生成

        print(PrxmlPrint('ExpBegin'))
        video_tracks = []
        audio_tracks = []
        for layer in zorder + ['SE','Voice']:
            # 气泡图层
            if layer[0:2] == 'Bb':
                track_items = parse_timeline_bubble(layer)
                bubble_clip_list = []
                text_clip_list = []
                for item in track_items:
                    bubble_this,text_this = eval('{0}.display(begin ={1},end={2},text="{3}",header="{4}")'
                                                .format(item[0],item[3],item[4],item[1],item[2]))
                    if bubble_this is not None:
                        # 气泡的返回值可能为空！
                        bubble_clip_list.append(bubble_this)
                    # 文本始终会有一个返回值
                    text_clip_list.append(text_this)
                video_tracks.append(track_tplt.format(**{'targeted':'False','clips':'\n'.join(bubble_clip_list)}))
                video_tracks.append(track_tplt.format(**{'targeted':'True','clips':'\n'.join(text_clip_list)}))
            # 音效图层
            elif layer in ['SE','Voice']:
                track_items = parse_timeline(layer)
                clip_list = []
                for item in track_items:
                    if item[0] in media_list:
                        clip_list.append(eval('{0}.display(begin={1})'.format(item[0],item[1])))
                    elif os.path.isfile(item[0][1:-1]) == True: # 注意这个位置的item[0]首尾应该有个引号
                        temp = Audio(item[0][1:-1])
                        clip_list.append(temp.display(begin=item[1]))
                    else:
                        print(WarningPrint('BadAuFile',item[0]))
                audio_tracks.append(audio_track_tplt.format(**{'type':Audio_type,'clips':'\n'.join(clip_list)}))
            # 立绘或者背景图层
            else:
                track_items = parse_timeline(layer)
                clip_list = []
                for item in track_items:
                    clip_list.append(eval('{0}.display(begin={1},end={2})'.format(item[0],item[1],item[2])))
                video_tracks.append(track_tplt.format(**{'targeted':'False','clips':'\n'.join(clip_list)}))

        main_output = project_tplt.format(**{'timebase':'%d'%frame_rate,
                            'ntsc':Is_NTSC,
                            'sequence_name':stdin_name,
                            'screen_width':'%d'%screen_size[0],
                            'screen_height':'%d'%screen_size[1],
                            'tracks_vedio':'\n'.join(video_tracks),
                            'tracks_audio':'\n'.join(audio_tracks)})

        ofile = open(output_path+'/'+stdin_name+'.xml','w',encoding='utf-8')
        ofile.write(main_output)
        ofile.close()
        print(PrxmlPrint('Done',output_path+'/'+stdin_name+'.xml'))
    if __name__ == '__main__':
        main()

elif args.Modules == 'export_video':
    from core.Exceptions import RplGenError, Print
    from core.Exceptions import ArgumentError, DecodeError, MediaError, RenderError, SyntaxsError
    from core.Exceptions import VideoPrint, WarningPrint
    Width = args.Width #显示的分辨率
    Height = args.Height
    frame_rate = args.FramePerSecond #帧率 单位fps
    zorder = args.Zorder.split(',') #渲染图层顺序

    # 初始化日志打印
    if args.Language == 'zh':
        # 中文
        Print.lang = 1 
        RplGenError.lang = 1
    else:
        # 英文
        Print.lang == 0
        RplGenError.lang = 0

    try:
        for path in [args.TimeLine,args.MediaObjDefine]:
            if path is None:
                print(path)
                raise ArgumentError('MissInput')
            if os.path.isfile(path) == False:
                raise ArgumentError('FileNotFound',path)

        if args.OutputPath is None:
            pass 
        elif os.path.isdir(args.OutputPath) == False:
            try:
                os.makedirs(args.OutputPath)
            except Exception:
                raise ArgumentError('MkdirErr',args.OutputPath)
        args.OutputPath = args.OutputPath.replace('\\','/')

        # FPS
        if frame_rate <= 0:
            raise ArgumentError('FrameRate',str(frame_rate))
        elif frame_rate>30:
            print(WarningPrint('HighFPS', str(frame_rate)))

        if (Width<=0) | (Height<=0):
            raise ArgumentError('Resolution',str((Width,Height)))
        if Width*Height > 3e6:
            print(WarningPrint('HighRes'))
    except Exception as E:
        print(E)
        sys.exit(1)

    import pandas as pd
    import numpy as np
    import pygame
    import ffmpeg
    import pydub
    import time
    import re
    import pickle

    # 自由点
    from core.FreePos import Pos,FreePos,PosGrid

    # 类定义 alpha 1.11.0

    from core.Medias import Text
    from core.Medias import StrokeText
    from core.Medias import Bubble
    from core.Medias import Balloon
    from core.Medias import DynamicBubble
    from core.Medias import ChatWindow
    from core.Medias import Background
    from core.Medias import Animation
    from core.Medias import GroupedAnimation
    from core.Medias import BuiltInAnimation
    from core.Medias import screen_config
    screen_config['screen_size'] = (Width,Height)
    screen_config['frame_rate'] = frame_rate

    from core.Medias import Audio_Video as Audio
    from core.Medias import BGM_Video as BGM

    # 处理bg 和 am 的parser
    def parse_timeline(layer):
        global timeline,break_point
        track = render_timeline[[layer]]
        clips = []
        item,begin,end = 'NA',0,0
        for key,values in track.iterrows():
            #如果item变化了，或者进入了指定的断点
            if (values[layer] != item) | (key in break_point.values): 
                if (item == 'NA') | (item!=item): # 如果itme是空 
                    pass # 则不输出什么
                else:
                    end = key #否则把当前key作为一个clip的断点
                    clips.append((item,begin,end)) #并记录下这个断点
                item = values[layer] #无论如何，重设item和begin
                begin = key
            else: #如果不满足断点要求，那么就什么都不做
                pass
        # 循环结束之后，最后检定一次是否需要输出一个clips
        end = key
        if (item == 'NA') | (item!=item):
            pass
        else:
            clips.append((item,begin,end))
        return clips #返回一个clip的列表

    # 渲染函数
    def render(this_frame):
        global media_list
        for layer in zorder:
            # 不渲染的条件：图层为"Na"，或者np.nan
            if (this_frame[layer]=='NA')|(this_frame[layer]!=this_frame[layer]):
                continue
            elif this_frame[layer+'_a']<=0: #或者图层的透明度小于等于0(由于fillna("NA"),出现的异常)
                continue
            elif this_frame[layer] not in media_list:
                raise RenderError('UndefMedia',this_frame[layer])
            elif layer[0:2] == 'BG':
                try:
                    exec('{0}.display(surface=screen,alpha={1},adjust={2},center={3})'.format(this_frame[layer],
                                                                                            this_frame[layer+'_a'],
                                                                                            '\"'+this_frame[layer+'_p']+'\"',
                                                                                            '\"'+this_frame[layer+'_c']+'\"'))
                except Exception:
                    raise RenderError('FailRender',this_frame[layer],'Background')
            elif layer[0:2] == 'Am': # 兼容H_LG1(1)这种动画形式 alpha1.6.3
                try:
                    exec('{0}.display(surface=screen,alpha={1},adjust={2},frame={3},center={4})'.format(
                                                                                            this_frame[layer],
                                                                                            this_frame[layer+'_a'],
                                                                                            '\"'+this_frame[layer+'_p']+'\"',
                                                                                            this_frame[layer+'_t'],
                                                                                            '\"'+this_frame[layer+'_c']+'\"'))
                except Exception:
                    raise RenderError('FailRender',this_frame[layer],'Animation')
            elif layer[0:2] == 'Bb':
                try:
                    exec('{0}.display(surface=screen,text={2},header={3},alpha={1},adjust={4},center={5})'.format(this_frame[layer],
                                                                                                    this_frame[layer+'_a'],
                                                                                                    '\"'+this_frame[layer+'_main']+'\"',
                                                                                                    '\"'+this_frame[layer+'_header']+'\"',
                                                                                                    '\"'+this_frame[layer+'_p']+'\"',
                                                                                                    '\"'+this_frame[layer+'_c']+'\"'))
                except Exception:
                    raise RenderError('FailRender',this_frame[layer],'Bubble')
        return 1

    # 被占用的变量名 # 1.7.7
    occupied_variable_name = open('./media/occupied_variable_name.list','r',encoding='utf8').read().split('\n')

    # Main():
    print(VideoPrint('Welcome',EDITION))
    print(VideoPrint('SaveAt',args.OutputPath))

    # 载入timeline 和 breakpoint
    timeline_ifile = open(args.TimeLine,'rb')
    render_timeline,break_point,bulitin_media = pickle.load(timeline_ifile)
    timeline_ifile.close()
    stdin_name = args.TimeLine.replace('\\','/').split('/')[-1]

    # 载入od文件
    try:
        object_define_text = open(args.MediaObjDefine,'r',encoding='utf-8').read()#.split('\n')
    except UnicodeDecodeError as E:
        print(DecodeError('DecodeErr',E))
        sys.exit(1)
    if object_define_text[0] == '\ufeff': # 139 debug
        print(WarningPrint('UFT8BOM'))
        object_define_text = object_define_text[1:]
    object_define_text = object_define_text.split('\n')

    media_list=[]
    for i,text in enumerate(object_define_text):
        if text == '':
            continue
        elif text[0] == '#':
            continue
        else:
            try:
                exec(text) #对象实例化
                obj_name = text.split('=')[0]
                obj_name = obj_name.replace(' ','')
                if obj_name in occupied_variable_name:
                    raise SyntaxsError('OccName')
                elif (len(re.findall('\w+',obj_name))==0)|(obj_name[0].isdigit()):
                    raise SyntaxsError('InvaName')
                media_list.append(obj_name) #记录新增对象名称
            except Exception as E:
                print(E)
                print(SyntaxsError('MediaDef',text,str(i+1)))
                sys.exit(1)
    black = Background('black')
    white = Background('white')
    media_list.append('black')
    media_list.append('white')
    # alpha 1.6.5 载入导出的内建媒体
    for key,values in bulitin_media.iteritems():
        exec(values)
        media_list.append(key)

    # 合成音轨

    print(VideoPrint('VideoBegin'))

    tracks = ['SE','Voice','BGM']
    main_Track = pydub.AudioSegment.silent(duration=int(break_point.values.max()/frame_rate*1000),frame_rate=48000) # 主轨道

    for tr in tracks:
        this_Track = pydub.AudioSegment.silent(duration=int(break_point.values.max()/frame_rate*1000),frame_rate=48000)
        if tr == 'BGM':
            BGM_clips = parse_timeline('BGM')
            for i,item in enumerate(BGM_clips):
                voice,begin,drop = item
                if voice == 'stop':
                    continue # 遇到stop，直切切到下一段
                elif voice not in media_list: # 如果是路径形式
                    temp_BGM = BGM(voice[1:-1]) # 去除引号
                    voice = 'temp_BGM'
                try:
                    end = BGM_clips[i+1][1]
                except IndexError:
                    end = break_point.values.max()
                # print(begin,end)
                # 这里似乎是有，BGM不正常循环的bug！！！！！！！！！！
                this_Track = this_Track.overlay(
                    pydub.AudioSegment.silent(duration=int((end-begin)/frame_rate*1000),frame_rate=48000).overlay(eval(voice+'.media'),loop=eval(voice+'.loop')),
                    position = int(begin/frame_rate*1000)
                    )
        else:
            for item in parse_timeline(tr):
                voice,begin,drop = item
                if voice not in media_list: # 如果是路径形式
                    temp_AU = Audio(voice[1:-1]) # 去除引号
                    voice = 'temp_AU'
                this_Track = this_Track.overlay(eval(voice+'.media'),position = int(begin/frame_rate*1000))
        main_Track = main_Track.overlay(this_Track) #合成到主音轨
        print(VideoPrint('TrackDone',tr))

    main_Track.export(args.OutputPath+'/'+stdin_name+'.mp3',format='mp3',codec='mp3',bitrate='256k')

    print(VideoPrint('AudioDone'))


    # 初始化

    print(VideoPrint('EncoStart'))

    pygame.init()
    screen = pygame.display.set_mode((Width,Height),pygame.HIDDEN)

    # 转换媒体对象
    for media in media_list: 
        try:
            exec(media+'.convert()')
        except Exception as E:
            print(MediaError('ErrCovert', media, E))
            sys.exit(1)

    # ffmpeg输出
    output_engine = (
        ffmpeg
        .input('pipe:',format='rawvideo',r=frame_rate,pix_fmt='rgb24', s='{0}x{1}'.format(Height,Width)) # 视频来源
        .output(ffmpeg.input(args.OutputPath+'/'+stdin_name+'.mp3').audio,
                args.OutputPath+'/'+stdin_name+'.mp4',
                pix_fmt='yuv420p',r=frame_rate,crf=args.Quality,
                **{'loglevel':'quiet','vf':'transpose=0'}) # 输出
        .overwrite_output()
        .run_async(pipe_stdin=True)
    )

    begin_time = time.time()
    # 主循环
    n=0
    while n < break_point.max():
        try:
            if n in render_timeline.index:
                this_frame = render_timeline.loc[n]
                render(this_frame)
                obyte = pygame.surfarray.array3d(screen).tobytes()
            else:
                pass # 节约算力
            output_engine.stdin.write(obyte) # 写入视频
            n = n + 1 #下一帧
        except Exception as E:
            print(E)
            print(RenderError('BreakFrame',n))
            output_engine.stdin.close()
            pygame.quit()
            sys.exit(1)
        if n%frame_rate == 1:
            finish_rate = n/break_point.values.max()
            used_time = time.time()-begin_time
            est_time = int(used_time/finish_rate * (1-finish_rate))
            print(VideoPrint('Progress',
                            '\x1B[33m' + int(finish_rate*50)*'━' + '\x1B[30m' + (50-int(50*finish_rate))*'━' + '\x1B[0m',
                            '%.1f'%(finish_rate*100)+'%', n, '%d'%break_point.values.max(), 
                            'eta: '+time.strftime("%H:%M:%S", time.gmtime(est_time))), end = "\r")

    # 改一个bug，如果最后一帧正好是显示帧，那么100% 不会正常显示
    print(VideoPrint('Progress', '\x1B[32m' + 50*'━' + '\x1B[0m', '%.1f'%100+'%', n, n ,' '*15))
    output_engine.stdin.close()
    pygame.quit()

    used_time = time.time()-begin_time

    print(VideoPrint('CostTime', time.strftime("%H:%M:%S", time.gmtime(used_time))))
    print(VideoPrint('RendSpeed', '%.2f'%(break_point.max()/used_time)))
    print(VideoPrint('Done',args.OutputPath+'/'+stdin_name+'.mp4'))

    sys.exit(0)

else:
    sys.exit(-1)